function Ie(e){return new Promise((t,n)=>{let o=document.createElement("script");o.src=e,o.onload=()=>t(o),o.onerror=a=>n(a),document.head.append(o)})}function le(e,t){return Reflect.has(globalThis,e)?Promise.resolve(Reflect.get(globalThis,e)):Ie(t).then(()=>Reflect.get(globalThis,e))}var he=new Array(256);for(let e=0;e<256;e++)he[e]=e.toString(16).padStart(2,"0");function m(e){if(!e||!(e instanceof Uint8Array))throw new TypeError("Input must be a Uint8Array");let t=e.length,n=new Array(t);for(let o=0;o<t;o++)n[o]=he[e[o]];return n.join("")}var de={get InvalidHexStringException(){throw new TypeError("Invalid hex string")}};function T(e){if(typeof e!="string")throw new TypeError("Input must be a string");let t=e.length;if(t%2!==0)throw new TypeError("Hex string must have even length");e=e.toLowerCase();let n=new Uint8Array(t>>1);for(let o=0;o<t;o+=2){let a=e.charCodeAt(o),s=e.charCodeAt(o+1),c=a>=97&&a<=102?a-87:a>=48&&a<=57?a-48:de.InvalidHexStringException,i=s>=97&&s<=102?s-87:s>=48&&s<=57?s-48:de.InvalidHexStringException;n[o>>1]=c<<4|i}return n}function A(e){let t=new Uint8Array(e);return crypto.getRandomValues(t),t}function Ue(){let e=A(1);return new Int8Array(e)[0]}function ce(){let e=A(1);return new Uint8Array(e)[0]}function x(e,t="utf-8"){if(typeof e!="string")throw new TypeError("Input must be a string");if(t.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextEncoder().encode(e)}function f(e,t="utf-8"){if(e instanceof Uint8Array||(e=new Uint8Array(e)),t.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextDecoder().decode(e)}var l=class extends Error{constructor(t="Encryption Error",n=void 0){super(t,n),this.name="EncryptionError"}},I=class extends l{constructor(t="(Internal Error)",n=void 0){super(t,n),this.name="InternalError"}};function me(e,t){throw new I(e,t)}var D=class extends l{constructor(t="The parameter provided is invalid.",n=void 0){super(t,n),this.name="InvalidParameterException"}},P=class extends l{constructor(t="The data is bad.",n=void 0){super(t,n),this.name="BadDataException"}},X=class extends l{constructor(t="The N, r, or p is not valid or out of range.",n=void 0){super(t,n),this.name="InvalidScryptParameterException"}},K=class extends l{constructor(t="The version of the encryption library doesn't match.",n=void 0){super(t,n),this.name="EncryptionVersionMismatchException"}},Y=class extends l{constructor(t="The file format is invalid.",n=void 0){super(t,n),this.name="InvalidFileFormatException"}},L=class extends l{constructor(t="IV Exception.",n=void 0){super(t,n),this.name="IVException"}},q=class extends l{constructor(t="File is corrupted.",n=void 0){super(t,n),this.name="FileCorruptedException"}},Z=class extends l{constructor(t="The end marker is invalid.",n=void 0){super(t,n),this.name="InvalidEndMarkerException"}},Q=class extends l{constructor(t="Cannot decrypt",n=void 0){super(t,n),this.name="CannotDecryptException"}};var B=await le("scrypt",import.meta.resolve("./WebScrypt/scrypt.js"));B.setResPath(import.meta.resolve("./WebScrypt/asset/"));B.load();var ue=function(){let e=[],t=!1,n=a=>new Promise(async(s,c)=>{B.onprogress=i=>{a.onprogress&&a.onprogress(i)},B.oncomplete=i=>{a.resolve(i),s(!0)},B.onerror=i=>{a.reject(i),s(!1)};try{B.config({N:a.N,r:a.r,P:a.p},{maxPassLen:8192,maxSaltLen:2048,maxDkLen:1024,maxThread:1}),await new Promise(i=>B.onready=i),B.hash(a.key,a.salt,a.dklen)}catch(i){c(i)}});async function o(){let a=null;for(;e.length;)try{a=e.splice(0,1)[0],await n(a),await Be()}catch(s){a?.reject(s)}t=!1}return function(s,c,i,r,p,u,y=null){return new Promise((h,k)=>{e.push({key:s,salt:c,N:i,r,p,dklen:u,resolve:h,reject:k,onprogress:y}),t||(t=!0,setTimeout(o))})}}(),Ae=["Furina","Neuvillette","Venti","Nahida","Kinich","Kazuha"];async function N(e,t,n=null,o=null,a=null,s=8,c=1,i=32){if(o===null&&(o=262144),typeof o!="number"||o>2097152)throw new X;if(a||(a=A(64)),n||(n=Ae[ce()%Ae.length]),n.includes(":"))throw new D('phrase MUST NOT contain ":"');let r=`${n}:${m(a)}`,p=`MyEncryption/1.1 Fontaine/4.2 Iv/${m(t)} user_parameter=${r} user_key=${e}`;return{derived_key:await ue(x(p),a,o,s,c,i),parameter:r,N:o}}function Be(){return new Promise(e=>setTimeout(e))}async function ke(e,t,n,o,a,s){return m(await ue(x(e),x(t),n,o,a,s))}function Te(e){try{return JSON.parse(e)}catch{throw new D("The JSON is not valid.")}}async function S(e,t,n=null,o=null){let a=A(12),{derived_key:s,parameter:c,N:i}=await N(t,a,n,o);o=i;let r=await crypto.subtle.importKey("raw",s,"AES-GCM",!1,["encrypt"]);typeof e=="string"&&(e=x(e));let p=await crypto.subtle.encrypt({name:"AES-GCM",iv:a},r,e),u=new Uint8Array(a.length+p.byteLength);u.set(a,0),u.set(new Uint8Array(p),a.length);let y=m(u);return JSON.stringify({data:y,parameter:c,N:o,v:5.5})}async function R(e,t){let n=Te(e),o=n.parameter,a=parseInt(n.N),s=T(n.data),[c,i]=o.split(":"),r=T(i);if(isNaN(a)||!o||!s||!r)throw new P("The message or parameters are bad.");if(s.length<28)throw new P("The message was too short.");let p=s.slice(0,12),u=s.slice(12,-16),y=s.slice(-16),{derived_key:h}=await N(t,p,c,a,r),k=await crypto.subtle.importKey("raw",h,"AES-GCM",!1,["decrypt"]);try{let w=await crypto.subtle.decrypt({name:"AES-GCM",iv:p},k,new Uint8Array([...u,...y]));try{return f(w)}catch{return w}}catch(w){if(!w)throw new I("Internal error.",{cause:w});let _=w.name;if(_==="InvalidAccessError")throw new D("InvalidAccessError.",{cause:w});if(_==="OperationError")throw new Q("Cannot decrypt. Did you provide the correct password?",{cause:w});if(!w)throw new I("Unexpected error.",{cause:w})}}function _e(){return new Promise(e=>requestAnimationFrame(e))}var te=4096;var ge=[85,170,85,170,85,170,85,170,170,85,170,85,170,85,170,85,85,170,85,170,85,170,85,170,170,85,170,85,170,85,170,85],ye=[85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170];function we(e,t){return e?t?`${e}/${t}`:`${e}/0`:"Unknown Version"}var M=we("1.1"),ee=we("1.2",10020);async function De(e,t,n,o=null,a=null,s=null,c=16*1024*1024){await t(x("MyEncryption/1.2"));let i=10020,r=new ArrayBuffer(4);new DataView(r).setUint32(0,i,!0),await t(new Uint8Array(r));let p=m(A(64)),u=await S(p,n),y=x(u);if(y.length>te)throw new I("(Internal Error) This should not happen. Contact the application developer.");let h=new ArrayBuffer(4);new DataView(h).setUint32(0,y.length,!0),await t(new Uint8Array(h)),await t(y);let k=new Uint8Array(te-y.length-4).fill(0);await t(k),o?.(0),await _e();let w=A(12),{derived_key:_,parameter:re,N:oe}=await N(p,w,a,s);s=oe;let ae={parameter:re,N:s,v:5.5,iv:m(w)},G=x(JSON.stringify(ae)),j=new ArrayBuffer(4);new DataView(j).setUint32(0,G.length,!0),await t(new Uint8Array(j)),await t(G);let $=new ArrayBuffer(8);new DataView($).setBigUint64(0,BigInt(c),!0),await t(new Uint8Array($));let V=0,d=1,F=0,C=new ArrayBuffer(8);new DataView(C).setBigUint64(0,BigInt(d),!0),await t(new Uint8Array(C)),o?.(0);let z=await crypto.subtle.importKey("raw",_,{name:"AES-GCM"},!1,["encrypt"]);for(;;){let U=await e(F,F+c);if(U.length===0)break;let ie=U.length<c,H=new ArrayBuffer(12);if(d>=2**64||d>=Number.MAX_SAFE_INTEGER)throw new L("nonce_counter exceeded the maximum value.");if(new DataView(H).setBigUint64(4,BigInt(d),!0),d++,ie){await t(new Uint8Array(ge));let O=new ArrayBuffer(8);new DataView(O).setBigUint64(0,BigInt(U.length),!0),await t(new Uint8Array(O))}let g=new Uint8Array(H),E=await crypto.subtle.encrypt({name:"AES-GCM",iv:g},z,U),W=new Uint8Array(E);await t(W),V+=U.length,F+=U.length,o?.(V)}await t(new Uint8Array(ye));let J=new ArrayBuffer(8);return new DataView(J).setBigUint64(0,BigInt(V),!0),await t(new Uint8Array(J)),await t(new Uint8Array([255,253,240,16,19,208,18,24,85,170])),!0}async function Ne(e,t,n,o=null){let a=await e(0,13);if(f(a)!=="MyEncryption/")throw new Y;let s=f(await e(13,16));if(!["1.1","1.2"].includes(s))throw new K;let c=new DataView((await e(16,20)).buffer).getUint32(0,!0),i=we(s,c),r=20,p,u,y;if(i===M&&(p=await e(r,r+4),u=new DataView(p.buffer).getUint32(0,!0),r+=4,y=f(await e(r,r+u)),r+=1024),i===ee&&(p=await e(r,r+4),u=new DataView(p.buffer).getUint32(0,!0),y=f(await e(r+4,r+4+u)),r+=te,u>te))throw new I("(Internal Error) This should not happen. Contact the application developer.");let h=await R(y,n),k=await e(r,r+4),w=new DataView(k.buffer).getUint32(0,!0);r+=4;let _=JSON.parse(f(await e(r,r+w)));r+=w;let re=_.v;if(![5.5].includes(re))throw new K;let[oe,ae]=_.parameter.split(":"),G=T(ae),j=T(_.iv),$=_.N,V,d;if(i===ee){let g=await e(r,r+8);V=Number(new DataView(g.buffer).getBigUint64(0,!0));let E=await e(r+8,r+16);d=Number(new DataView(E.buffer).getBigUint64(0,!0)),r+=16}o?.(0),await _e();let{derived_key:F}=await N(h,j,oe,$,G),C=0,z=!1,J=await crypto.subtle.importKey("raw",F,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let g=await e(r,r+8);i===M&&(r+=8);let E=0;if(i===M){if(g.every((b,v)=>b===[255,253,240,16,19,208,18,24][v]))break}else if(g.every((b,v)=>b===ye[v])){let b=await e(r,r+32);if(b.every((v,se)=>v===ye[se]))break;if(b.every((v,se)=>v===ge[se])){z=!0,r+=32;let v=await e(r,r+8);if(r+=8,E=Number(new DataView(v.buffer).getBigUint64(0,!0)),E===0)break}}let W=i===M?Number(new DataView(g.buffer).getBigUint64(0,!0)):i===ee?z?E:V:me("Code was tampered with"),O=new ArrayBuffer(12);if(i===ee){if(d>=2**64||d>=Number.MAX_SAFE_INTEGER)throw new L("nonce_counter exceeded the maximum value.");let b=new DataView(O);b.setInt32(0,0,!0),b.setBigUint64(4,BigInt(d),!0),d++}let Ee=i===M?await e(r,r+12):new Uint8Array(O);i===M&&(r+=12);let be=await e(r,r+W+16);r+=W+16;let ve=be,fe=await crypto.subtle.decrypt({name:"AES-GCM",iv:Ee},J,ve);await t(new Uint8Array(fe)),C+=fe.byteLength,o&&o(C)}let U=await e(r,r+8),ie=Number(new DataView(U.buffer).getBigUint64(0,!0));r+=8;let H=await e(r,r+2);if(C!==ie)throw new q("total bytes mismatch");if(!H.every((g,E)=>g===[85,170][E]))throw new Z;return!0}async function Ve(e,t,n){if(e.size<1044)throw new Error("Data not enough");if(await e.slice(0,16).text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let s=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),c=await e.slice(20,20+s).arrayBuffer(),i=f(c);return await S(await R(i,t))}async function Ce(e,t,n){if(e.size<1044)throw new Error("Data not enough");let o=e.slice(0,16);if(await o.text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let s=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),c=f(await e.slice(20,20+s).arrayBuffer()),i=await S(await R(c,t),n);if(i.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let r=i.length,p=new ArrayBuffer(4);new DataView(p).setUint32(0,r,!0);let y=[o,p,x(i)],h=new Uint8Array(1024-i.length).fill(0);return y.push(h),new Blob(y)}var xe=Object.create(null);xe[Symbol.toStringTag]="CryptContext";xe.toString=function(){return`${this[Symbol.toStringTag]} Object`};async function ne(e){return e instanceof Promise?await e:e}async function Se(){let e=Object.create(xe);return e._created=!0,e}async function Re(e){for(let t of Reflect.ownKeys(e)){let n=Reflect.get(e,t);n&&(n.release?await ne(n.release()):n.free?await ne(n.free()):n.reset?await ne(n.reset()):n.clear&&await ne(n.clear())),t.startsWith("_")||Reflect.deleteProperty(e,t)}return e._released=!0,!0}var Me="Encryption/5.5 FileEncryption/1.2";export{Me as VERSION,Ce as change_file_password,Se as crypt_context_create,Re as crypt_context_destroy,R as decrypt_data,Ne as decrypt_file,N as derive_key,S as encrypt_data,De as encrypt_file,Ve as export_master_key,A as get_random_bytes,Ue as get_random_int8_number,ce as get_random_uint8_number,m as hexlify,ue as scrypt,ke as scrypt_hex,f as str_decode,x as str_encode,T as unhexlify};
//# sourceMappingURL=main.bundle.js.map
