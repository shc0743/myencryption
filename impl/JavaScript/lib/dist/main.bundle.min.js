var Ze=Object.defineProperty;var Ke=(e,t)=>{for(var n in t)Ze(e,n,{get:t[n],enumerable:!0})};var je=new Array(256);for(let e=0;e<256;e++)je[e]=e.toString(16).padStart(2,"0");function z(e){if(!e||!(e instanceof Uint8Array))throw new TypeError("Input must be a Uint8Array");let t=e.length,n=new Array(t);for(let i=0;i<t;i++)n[i]=je[e[i]];return n.join("")}var Ge={get InvalidHexStringException(){throw new TypeError("Invalid hex string")}};function F(e){if(typeof e!="string")throw new TypeError("Input must be a string");let t=e.length;if(t%2!==0)throw new TypeError("Hex string must have even length");e=e.toLowerCase();let n=new Uint8Array(t>>1);for(let i=0;i<t;i+=2){let r=e.charCodeAt(i),o=e.charCodeAt(i+1),a=r>=97&&r<=102?r-87:r>=48&&r<=57?r-48:Ge.InvalidHexStringException,s=o>=97&&o<=102?o-87:o>=48&&o<=57?o-48:Ge.InvalidHexStringException;n[i>>1]=a<<4|s}return n}function K(e){let t=new Uint8Array(e);return crypto.getRandomValues(t),t}function Xe(){let e=K(1);return new Int8Array(e)[0]}function Pe(){let e=K(1);return new Uint8Array(e)[0]}function C(e,t="utf-8"){if(typeof e!="string")throw new TypeError("Input must be a string");if(t.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextEncoder().encode(e)}function h(e,t="utf-8"){if(e instanceof Uint8Array||(e=new Uint8Array(e)),t.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextDecoder().decode(e)}var Y={};Ke(Y,{BadDataException:()=>M,CannotDecryptException:()=>te,ChaCha20NotSupportedException:()=>Ne,CryptContextNotInitedException:()=>ve,CryptContextReleasedException:()=>Ie,CryptContextReusedException:()=>ge,DangerousEncryptionAlgorithmException:()=>ke,DataError:()=>$,EncryptionAlgorithmNotSupportedException:()=>J,EncryptionError:()=>he,EncryptionVersionMismatchException:()=>R,EndOfFileException:()=>Oe,ExpectedError:()=>Ce,FileCorruptedException:()=>le,IVException:()=>Ee,InputError:()=>ue,InternalError:()=>b,InvalidCryptContextTypeException:()=>be,InvalidEndMarkerException:()=>de,InvalidFileFormatException:()=>ee,InvalidParameterException:()=>m,InvalidScryptParameterException:()=>me,LibraryError:()=>ye,NetworkError:()=>xe,NotSupportedException:()=>ne,OperationNotPermittedException:()=>H,ParameterError:()=>G,RuntimeException:()=>pe,UnexpectedError:()=>_e,UnexpectedFailureInChunkDecryptionException:()=>Ae,UserException:()=>Ue,VersionSystemError:()=>Te});var ye=class extends Error{constructor(t="Library Error",n=void 0){super(t,n),this.name="LibraryError"}},he=class extends ye{constructor(t="Encryption Error",n=void 0){super(t,n),this.name="EncryptionError"}},xe=class extends ye{constructor(t="(Network Error)",n=void 0){super(t,n),this.name="NetworkError"}},Ce=class extends he{constructor(t="(Expected Error)",n=void 0){super(t,n),this.name="ExpectedError"}},pe=class extends he{constructor(t="(Runtime Error)",n=void 0){super(t,n),this.name="RuntimeException"}},_e=class extends pe{constructor(t="(Unexpected Error)",n=void 0){super(t,n),this.name="UnexpectedError"}},b=class extends _e{constructor(t="(Internal Error)",n=void 0){super(t,n),this.name="InternalError"}},ue=class extends pe{constructor(t="(Input Error)",n=void 0){super(t,n),this.name="InputError"}},G=class extends ue{constructor(t="(Data Error)",n=void 0){super(t,n),this.name="ParameterError"}},$=class extends ue{constructor(t="(Data Error)",n=void 0){super(t,n),this.name="DataError"}},Ue=class extends pe{constructor(t="(The end user has a fault that caused the exception. This is not code bug.)",n=void 0){super(t,n),this.name="UserException"}},Te=class extends ${constructor(t="(Version System Error)",n=void 0){super(t,n),this.name="VersionSystemError"}},m=class extends G{constructor(t="The parameter provided is invalid.",n=void 0){super(t,n),this.name="InvalidParameterException"}},M=class extends ${constructor(t="The data is bad.",n=void 0){super(t,n),this.name="BadDataException"}},me=class extends G{constructor(t="The N, r, or p is not valid or out of range.",n=void 0){super(t,n),this.name="InvalidScryptParameterException"}},R=class extends Te{constructor(t="The version of the encryption library doesn't match.",n=void 0){super(t,n),this.name="EncryptionVersionMismatchException"}},ee=class extends ${constructor(t="The file format is invalid.",n=void 0){super(t,n),this.name="InvalidFileFormatException"}},Ee=class extends b{constructor(t="IV Exception.",n=void 0){super(t,n),this.name="IVException"}},le=class extends ${constructor(t="File is corrupted.",n=void 0){super(t,n),this.name="FileCorruptedException"}},de=class extends ${constructor(t="The end marker is invalid.",n=void 0){super(t,n),this.name="InvalidEndMarkerException"}},te=class extends Ue{constructor(t="Cannot decrypt",n=void 0){super(t,n),this.name="CannotDecryptException"}},Ae=class extends _e{constructor(t="An unexpected failure occurred while decrypting the chunk. The file may be corrupted.",n=void 0){super(t,n),this.name="UnexpectedFailureInChunkDecryptionException"}},ge=class extends G{constructor(t="Not allowed to reuse a crypt context.",n=void 0){super(t,n),this.name="CryptContextReusedException"}},ne=class extends ue{constructor(t="Operation not supported",n=void 0){super(t,n),this.name="NotSupportedException"}},Oe=class extends Ce{constructor(t="End of File",n=void 0){super(t,n),this.name="EndOfFileException"}},ve=class extends G{constructor(t="Crypt context is not initialized.",n=void 0){super(t,n),this.name="CryptContextNotInitedException"}},be=class extends G{constructor(t="Invalid crypt context type.",n=void 0){super(t,n),this.name="InvalidCryptContextTypeException"}},Ie=class extends G{constructor(t="Crypt context has been released.",n=void 0){super(t,n),this.name="CryptContextReleasedException"}},H=class extends G{constructor(t="Operation not permitted.",n=void 0){super(t,n),this.name="OperationNotPermittedException"}},J=class extends ${constructor(t="The specified encryption algorithm is not supported.",n=void 0){super(t,n),this.name="EncryptionAlgorithmNotSupportedException"}},Ne=class extends J{constructor(t="ChaCha20 is not supported yet.",n=void 0){super(t,n),this.name="ChaCha20NotSupportedException"}},ke=class extends J{constructor(t="The specified encryption algorithm is DANGEROUS.",n=void 0){super(t,n),this.name="DangerousEncryptionAlgorithmException"}};function qe(e){return new Promise((t,n)=>{let i=document.createElement("script");i.src=e,i.onload=()=>t(i),i.onerror=r=>n(r),document.head.append(i)})}function $e(e,t){return Reflect.has(globalThis,e)?Promise.resolve(Reflect.get(globalThis,e)):qe(t).then(()=>Reflect.get(globalThis,e))}var W=await $e("scrypt",import.meta.resolve("./WebScrypt/scrypt.js"));W.setResPath(import.meta.resolve("./WebScrypt/asset/"));W.load();var De=function(){let e=[],t=!1,n=r=>new Promise(async(o,a)=>{W.onprogress=s=>{r.onprogress&&r.onprogress(s)},W.oncomplete=s=>{r.resolve(s),o(!0)},W.onerror=s=>{r.reject(s),o(!1)};try{W.config({N:r.N,r:r.r,P:r.p},{maxPassLen:8192,maxSaltLen:2048,maxDkLen:1024,maxThread:1}),await new Promise(s=>W.onready=s),W.hash(r.key,r.salt,r.dklen)}catch(s){a(s)}});async function i(){let r=null;for(;e.length;)try{r=e.splice(0,1)[0],await n(r),await Qe()}catch(o){r?.reject(o)}t=!1}return function(o,a,s,l,c,w,p=null){return new Promise((y,v)=>{e.push({key:o,salt:a,N:s,r:l,p:c,dklen:w,resolve:y,reject:v,onprogress:p}),t||(t=!0,setTimeout(i))})}}();function Qe(){return new Promise(e=>setTimeout(e))}var Ye=["Furina","Neuvillette","Venti","Nahida","Kinich","Kazuha"];async function j(e,t,n=null,i=null,r=null,o=8,a=1,s=32){if(i===null&&(i=262144),typeof i!="number"||i>2097152)throw new me;if(r||(r=K(64)),n||(n=Ye[Pe()%Ye.length]),n.includes(":"))throw new m('phrase MUST NOT contain ":"');let l=`${n}:${z(r)}`,c=`MyEncryption/1.1 Fontaine/4.2 Iv/${z(t)} user_parameter=${l} user_key=${e}`;return{derived_key:await De(C(c),r,i,o,a,s),parameter:l,N:i}}async function et(e,t,n,i,r,o){return z(await De(C(e),C(t),n,i,r,o))}var I=4096,we=[85,170,85,170,85,170,85,170],re=[85,170,85,170,85,170,85,170,170,85,170,85,170,85,170,85,85,170,85,170,85,170,85,170,170,85,170,85,170,85,170,85],oe=[85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170],Z=[255,253,240,16,19,208,18,24,85,170],tt=typeof process>"u"?requestAnimationFrame:setTimeout;function fe(){return new Promise(e=>tt(e))}function ie(e,t){return e?(String(e)==="1.1"&&(t=null),t?`${e}/${t}`:`${e}/0`):"Unknown Version"}var ae=ie("1.1"),se=ie("1.2",10020);async function X(e){let t=await e(0,13);if(h(t)!=="MyEncryption/")throw new ee;let n=h(await e(13,16));if(!["1.1","1.2"].includes(n))throw new R;let i=new DataView((await e(16,20)).buffer).getUint32(0,!0);return ie(n,i)}async function Be(e){let t=await X(e);if(t===ae)throw new H("The chunk size is volatile and we cannot get a fixed value.");if(t===se){let n=20;n+=I;let i=await e(n,n+4),r=new DataView(i.buffer).getUint32(0,!0);n+=4,n+=r;let o=Number(new DataView((await e(n,n+8)).buffer).getBigUint64(0,!0)),a=Number(new DataView((await e(n+8,n+16)).buffer).getBigUint64(0,!0));return{version:t,chunk_size:o,nonce_counter:a}}throw new R}async function He(e){return(await Be(e)).chunk_size}function Re(e){if(e&&e!=="AES-GCM")throw e==="ChaCha20"||e==="ChaCha20-Poly1305"?new Ne:e==="DES"||e==="RC4"?new ke:e==="XTS-AES"?new J("XTS-AES Not supported yet"):new J(void 0,{cause:new Error(String(e))})}async function nt(e){if(typeof e!="string")return!1;if(e.charAt(0)===":"){let t=e.split(":");if(t.length===8){let[,n,i,r,o,a,s]=t;return!!(n&&i&&r&&o&&a&&s)}return!1}if(e.charAt(0)!=="{")return!1;try{let t=JSON.parse(e);return t.data&&t.parameter&&t.N&&t.v}catch{return!1}}async function rt(e){try{return!!(await Be(e)).version}catch{return!1}}function ot(e){try{return JSON.parse(e)}catch{throw new m("The JSON is not valid.")}}async function q(e,t,n=null,i=null){let r=K(12),{derived_key:o,parameter:a,N:s}=await j(t,r,n,i);i=s;let l=await crypto.subtle.importKey("raw",o,"AES-GCM",!1,["encrypt"]);if(typeof e!="string")throw new H("The ability to directly encrypt binary data has been removed in the new version. Please use `encrypt_file` instead.");let c="AES-GCM",w=await crypto.subtle.encrypt({name:c,iv:r},l,C(e)),p=new Uint8Array(r.length+w.byteLength);return p.set(r,0),p.set(new Uint8Array(w),r.length),`:${z(p)}:${a}:${i}:${5.6}:${c}:`}async function P(e,t){let n;if(e.charAt(0)===":"){let d=e.split(":");if(d.length!==8)throw new M("The message is bad.");let[,A,S,V,x,u,U]=d;n={data:A,phrase:S,salt:V,N:+x,v:+u,a:U}}else n=ot(e);let i=parseInt(n.N),r=n.a;Re(r);let o=F(n.data),a,s;n.parameter?[a,s]=n.parameter.split(":"):(a=n.phrase,s=n.salt);let l=F(s);if(isNaN(i)||!a||!o||!l)throw new M("The message or parameters are bad.");if(o.length<28)throw new M("The message was too short.");let c=o.slice(0,12),w=o.slice(12,-16),p=o.slice(-16),y=typeof t=="string"?(await j(t,c,a,i,l)).derived_key:t,v=await crypto.subtle.importKey("raw",y,"AES-GCM",!1,["decrypt"]);try{let d=await crypto.subtle.decrypt({name:"AES-GCM",iv:c},v,new Uint8Array([...w,...p]));try{return h(d)}catch{throw new H("The ability to directly decrypt binary data has been removed in the new version. If you have encrypted binary data, please recover it using the old version.")}}catch(d){if(!d)throw new b("Internal error.",{cause:d});let A=d.name;if(A==="InvalidAccessError")throw new m("InvalidAccessError.",{cause:d});if(A==="OperationError")throw new te("Cannot decrypt. Did you provide the correct password?",{cause:d});if(!d)throw new b("Unexpected error.",{cause:d})}}async function it(e,t,n,i=null,r=null,o=null,a=32*1024*1024){if(!a)throw new m("chunk_size must be greater than 0.");await t(C("MyEncryption/1.2"));let s=10020,l=new ArrayBuffer(4);new DataView(l).setUint32(0,s,!0),await t(new Uint8Array(l));let c=z(K(64)),w=await q(c,n),p=C(w);if(p.length>I)throw new b("(Internal Error) This should not happen. Contact the application developer.");let y=new ArrayBuffer(4);new DataView(y).setUint32(0,p.length,!0),await t(new Uint8Array(y)),await t(p);let v=new Uint8Array(I-p.length-4).fill(0);await t(v),i?.(0),await fe();let d=K(12),{derived_key:A,parameter:S,N:V}=await j(c,d,r,o);o=V;let x={parameter:S,N:o,v:5.5,a:"AES-GCM",iv:z(d)},u=C(JSON.stringify(x)),U=new ArrayBuffer(4);new DataView(U).setUint32(0,u.length,!0),await t(new Uint8Array(U)),await t(u);let T=new ArrayBuffer(8);new DataView(T).setBigUint64(0,BigInt(a),!0),await t(new Uint8Array(T));let B=0,N=1,k=0,D=new ArrayBuffer(8);new DataView(D).setBigUint64(0,BigInt(N),!0),await t(new Uint8Array(D)),i?.(0);let f=await crypto.subtle.importKey("raw",A,{name:"AES-GCM"},!1,["encrypt"]);for(;;){let g=await e(k,k+a);if(!(g instanceof Uint8Array))throw new M("The file chunk is not a Uint8Array.");if(g.length===0)break;let O=g.length<a,Q=new ArrayBuffer(12);if(N>=2**64||N>=Number.MAX_SAFE_INTEGER)throw new Ee("nonce_counter exceeded the maximum value.");if(new DataView(Q).setBigUint64(4,BigInt(N),!0),N++,O){await t(new Uint8Array(re));let E=new ArrayBuffer(8);new DataView(E).setBigUint64(0,BigInt(g.length),!0),await t(new Uint8Array(E))}let ce=new Uint8Array(Q),Ve=await crypto.subtle.encrypt({name:"AES-GCM",iv:ce},f,g),Fe=new Uint8Array(Ve);await t(Fe),B+=g.length,k+=g.length,i?.(B)}await t(new Uint8Array(oe));let _=new ArrayBuffer(8);return new DataView(_).setBigUint64(0,BigInt(B),!0),await t(new Uint8Array(_)),await t(new Uint8Array(Z)),!0}async function at(e,t,n,i=null){let r=await e(0,16);if(h(r)!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let o=16,a=await e(o,o+4),s=new DataView(a.buffer).getUint32(0,!0);o+=4;let l=h(await e(o,o+s));o+=1024;let c=await P(l,n),w=await e(o,o+4),p=new DataView(w.buffer).getUint32(0,!0);o+=4;let y=JSON.parse(h(await e(o,o+p)));o+=p;let[v,d]=y.parameter.split(":"),A=F(d),S=F(y.iv),V=y.N;i?.(0),await fe();let{derived_key:x}=await j(c,S,v,V,A),u=0,U=await crypto.subtle.importKey("raw",x,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let k=await e(o,o+8);if(o+=8,k.every((Q,ce)=>Q===[255,253,240,16,19,208,18,24][ce]))break;let D=Number(new DataView(k.buffer).getBigUint64(0,!0)),f=await e(o,o+12);o+=12;let _=await e(o,o+D+16);o+=D+16;let g=_,O=await crypto.subtle.decrypt({name:"AES-GCM",iv:f},U,g);await t(new Uint8Array(O)),u+=O.byteLength,i&&i(u)}let T=await e(o,o+8),B=Number(new DataView(T.buffer).getBigUint64(0,!0));o+=8;let N=await e(o,o+2);if(u!==B)throw new le("File corrupted: total bytes mismatch");if(!N.every((k,D)=>k===[85,170][D]))throw new de("Invalid end marker");return!0}async function st(e,t,n,i=null){let r=20;if(await X(e)===ae){if(typeof n!="string")throw new ne("operation not supported");return await at(e,t,n,i)}let a=new DataView((await e(r,r+4)).buffer).getUint32(0,!0),s=h(await e(r+4,r+4+a));if(r+=I,a>I)throw new b("(Internal Error) This should not happen. Contact the application developer.");let l=typeof n=="string"?await P(s,n):null,c=await e(r,r+4),w=new DataView(c.buffer).getUint32(0,!0);r+=4;let p=JSON.parse(h(await e(r,r+w)));r+=w;let y=p.v;if(![5.5].includes(y))throw new R;let[v,d]=p.parameter.split(":"),A=F(d),S=F(p.iv),V=p.N,x=p.a;Re(x);let u=Number(new DataView((await e(r,r+8)).buffer).getBigUint64(0,!0)),U=Number(new DataView((await e(r+8,r+16)).buffer).getBigUint64(0,!0));r+=16,i?.(0),await fe();let T=typeof n=="string"?(await j(l,S,v,V,A)).derived_key:n,B=0,N=!1,k=await crypto.subtle.importKey("raw",T,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let g=await e(r,r+8),O=0;if(g.every((E,L)=>E===we[L])){let E=await e(r,r+32);if(E.every((L,Me)=>L===oe[Me])){r+=32;break}if(E.every((L,Me)=>L===re[Me])){N=!0,r+=32;let L=await e(r,r+8);if(r+=8,O=Number(new DataView(L.buffer).getBigUint64(0,!0)),O===0)break}}let Q=N?O:u,ce=new ArrayBuffer(12);new DataView(ce).setBigUint64(4,BigInt(U),!0),U++;let Ve=await e(r,r+Q+16);r+=Q+16;let Fe=Ve;try{let E=await crypto.subtle.decrypt({name:"AES-GCM",iv:new Uint8Array(ce)},k,Fe);await t(new Uint8Array(E)),B+=E.byteLength}catch(E){if(!E)throw new b("Internal error.",{cause:E});let L=E.name;if(L==="InvalidAccessError")throw new m("InvalidAccessError.",{cause:E});if(L==="OperationError")throw new Ae(void 0,{cause:E});if(!E)throw new b("Unexpected error.",{cause:E})}i&&i(B)}let D=await e(r,r+8),f=Number(new DataView(D.buffer).getBigUint64(0,!0));r+=8;let _=await e(r,r+Z.length);if(B!==f)throw new le("total bytes mismatch");if(!_.every((g,O)=>g===Z[O]))throw new de;return!0}async function ct(e,t,n){if(e.size<1044)throw new M("Data not enough");let i=await X(async(r,o)=>new Uint8Array(await e.slice(r,o).arrayBuffer()));if(i===ae){let r=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),o=await e.slice(20,20+r).arrayBuffer(),a=h(o);return await q(await P(a,t),n)}if(i===se){if(e.size<16+I)throw new M("Data not enough");let r=new DataView(await e.slice(20,24).arrayBuffer()).getUint32(0,!0),o=await e.slice(24,24+r).arrayBuffer(),a=h(o);return await q(await P(a,t),n)}throw new R}async function pt(e,t,n){if(e.size<1044)throw new Error("Data not enough");let i=e.slice(0,16);if(await i.text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let o=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),a=h(await e.slice(20,20+o).arrayBuffer()),s=await q(await P(a,t),n);if(s.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let l=s.length,c=new ArrayBuffer(4);new DataView(c).setUint32(0,l,!0);let p=[i,c,C(s)],y=new Uint8Array(1024-s.length).fill(0);return p.push(y),new Blob(p)}async function ut(e,t,n){if(e.size<1044)throw new Error("Data not enough");if(await X(async(y,v)=>new Uint8Array(await e.slice(y,v).arrayBuffer()))===ae)return await pt(e,t,n);let r=new DataView(await e.slice(20,24).arrayBuffer()).getUint32(0,!0),o=h(await e.slice(24,24+r).arrayBuffer()),a=await q(await P(o,t),n);if(a.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let s=a.length,l=new ArrayBuffer(4);new DataView(l).setUint32(0,s,!0);let w=[e.slice(0,20),l,C(a)],p=new Uint8Array(I-a.length-4).fill(0);return w.push(p),new Blob(w)}var Le=Object.create(null);Le[Symbol.toStringTag]="CryptContext";Le.toString=function(){return`${this[Symbol.toStringTag]} Object`};async function Se(e){return e instanceof Promise?await e:e}async function lt(){let e=Object.create(Le);return Object.defineProperty(e,"_created",{value:!0}),e}async function dt(e){if(!e||e._released)throw new m("Invalid context");for(let t of Reflect.ownKeys(e)){if(typeof t=="symbol"){Reflect.deleteProperty(e,t);continue}let n=Reflect.get(e,t);n&&(n.release?await Se(n.release()):n.free?await Se(n.free()):n.reset?await Se(n.reset()):n.clear&&await Se(n.clear())),t.startsWith("_")||Reflect.deleteProperty(e,t)}return Object.defineProperty(e,"_released",{value:!0}),!0}var ze=class{#n=null;#e={position:null,end:null,data:null};#t=null;get[Symbol.toStringTag](){return"Stream"}constructor(t,n){if(typeof t!="function")throw new m("Stream: Invalid reader");if(this.#n=t,typeof n!="number")throw new m("Stream: Invalid size");this.#t=n}get size(){return this.#t}#r=null;async read(t,n,i=null,r=null){if(!this.#n)throw new Error("Stream: The stream has been closed.");if(this.#e.position!=null&&this.#e.end&&this.#e.data&&t>=this.#e.position&&n<=this.#e.end)return this.#e.data.slice(t-this.#e.position,n-this.#e.position);if(t<0)throw new m("Stream: Invalid start position");if(n>this.#t&&(n=this.#t),i>this.#t&&(i=this.#t),this.#r=r,i){let a=await this.#n(t,i,r?.signal);return this.#r=null,this.#e.position=t,this.#e.end=t+a.length,this.#e.data=a,a.slice(0,n-t)}let o=await this.#n(t,n,r?.signal);return this.#r=null,o}abort(){this.#r?.abort()}purge(){this.#e.position=this.#e.data=this.#e.end=null}close(){this.#n=null,this.purge()}};async function wt(e,t,n,{cache:i=!0,cache_max_size:r=256*1024*1024}={}){if(e._inited)throw new ge;Object.defineProperty(e,"_inited",{value:!0}),e._type="@decrypt_stream",e.stream={stream:t,release:()=>e.stream.stream.close()};let o=await t.read(0,13,5e3);if(h(o)!=="MyEncryption/")throw new ee;let a=h(await t.read(13,16));if(!["1.1","1.2"].includes(a))throw new R;let s=new DataView((await t.read(16,20)).buffer).getUint32(0,!0),l=ie(a,s),c=20;if(l!==se)throw new ne("Cannot perform a streamed decryption on V1.1 files");let w=new DataView((await t.read(c,c+4)).buffer).getUint32(0,!0),p=h(await t.read(c+4,c+4+w));if(c+=I,w>I)throw new b("(Internal Error) This should not happen. Contact the application developer.");let y=await P(p,n),v=await t.read(c,c+4),d=new DataView(v.buffer).getUint32(0,!0);c+=4;let A=JSON.parse(h(await t.read(c,c+d)));c+=d;let S=A.v;if(![5.5].includes(S))throw new R;let[V,x]=A.parameter.split(":"),u=F(x),U=F(A.iv),T=A.N,B=Number(new DataView((await t.read(c,c+8)).buffer).getBigUint64(0,!0)),N=Number(new DataView((await t.read(c+8,c+16)).buffer).getBigUint64(0,!0));c+=16;let{derived_key:k}=await j(y,U,V,T,u),D=await crypto.subtle.importKey("raw",k,{name:"AES-GCM"},!1,["decrypt"]);return e.key=D,e.chunk_size=B,e.nonce_counter=N,e.header_json_length=d,e.cache_enabled=!!i,e.cached_chunks=new Map,e.cached_chunks_add_order=new Array,e.cached_size=0,e.cache_max_size=r,!0}async function ft(e,t,n,i){if(!e._inited)throw new ve;if(e._type!=="@decrypt_stream")throw new be(e._type);if(e._released)throw new Ie;let r=e.stream.stream,o=e.chunk_size,a=e.nonce_counter,s=[],l=20+I+4+e.header_json_length+8+8,c=o+16,w=Math.floor((r.size-l-(80+Z.length))/c),p=Math.max(0,Math.floor(t/o)),y=Math.min(w,Math.floor(n/o));if(y<0||p>w)throw new m("Out of range");let v=async x=>{if(e.cache_enabled&&e.cached_chunks.has(x))return e.cached_chunks.get(x);let u=l+x*c,U=await r.read(u,u+8,u+2*c,i),T=0;if(U.every((f,_)=>f===we[_])){let f=await r.read(u,u+32,null,i);if(u+=32,f.every((_,g)=>_===oe[g]))return!1;if(f.every((_,g)=>_===re[g])){let _=await r.read(u,u+8,null,i);if(u+=8,T=Number(new DataView(_.buffer).getBigUint64(0,!0)),T===0)return!1}}let B=T||o,N=await r.read(u,u+B+16,null,i),k=a+x,D=new ArrayBuffer(12);new DataView(D).setBigUint64(4,BigInt(k),!0);try{let f=await crypto.subtle.decrypt({name:"AES-GCM",iv:new Uint8Array(D)},e.key,N);if(e.cache_enabled)for(f.byteLength<e.cache_max_size&&(e.cached_chunks_add_order.push(x),e.cached_chunks.set(x,f),e.cached_size+=f.byteLength);e.cached_size>e.cache_max_size;){let _=e.cached_chunks_add_order.shift();e.cached_size-=e.cached_chunks.get(_).byteLength,e.cached_chunks.delete(_)}return f}catch(f){if(!f)throw new b("Internal error.",{cause:f});let _=f.name;if(_==="InvalidAccessError")throw new m("InvalidAccessError.",{cause:f});if(_==="OperationError")throw new te("Cannot decrypt. Did you provide the correct password?",{cause:f});if(!f)throw new b("Unexpected error.",{cause:f})}},d=!1;for(let x=p;x<=y;x++){let u=await v(x);if(!u){d=!0;break}s.push(u)}let A=new Blob(s),S=p*o,V=A.slice(t-S,n-S);return d&&(V.eof=!0),V}var yt={PADDING_SIZE:I,END_IDENTIFIER:we,TAIL_BLOCK_MARKER:re,END_MARKER:oe,FILE_END_MARKER:Z,nextTick:fe,GetFileVersion:X,GetFileInfo:Be,GetFileChunkSize:He};var We={};Ke(We,{createReaderForFileSystemHandle:()=>ht,createReaderForLocalFile:()=>Je,createReaderForRemoteObject:()=>xt,createWriterForFileSystemHandle:()=>_t,createWriterForMemoryBuffer:()=>mt});async function Je(e){return async(t,n)=>new Uint8Array(await e.slice(t,n).arrayBuffer())}async function ht(e){let t=await e.getFile();return await Je(t)}async function xt(e){return async(t,n)=>{let i=await fetch(e,{headers:{Range:`bytes=${t}-${n-1}`}});if(!i.ok)throw new xe(`Network Error: HTTP ${i.status} : ${i.statusText}`,{response:i});return new Uint8Array(await i.arrayBuffer())}}async function _t(e){let t=await e.createWritable();return async n=>{await t.write(n)}}async function mt(e){return async t=>{e.push(t)}}var Et="Encryption/5.6 FileEncryption/1.2 Patch/5.0 Package/1.5.50";export{ae as ENCRYPTION_FILE_VER_1_1_0,se as ENCRYPTION_FILE_VER_1_2_10020,Y as Exceptions,ze as InputStream,yt as Internals,Et as VERSION,We as Wrappers,ut as change_file_password,lt as crypt_context_create,dt as crypt_context_destroy,P as decrypt_data,st as decrypt_file,ft as decrypt_stream,wt as decrypt_stream_init,j as derive_key,q as encrypt_data,it as encrypt_file,ct as export_master_key,K as get_random_bytes,Xe as get_random_int8_number,Pe as get_random_uint8_number,z as hexlify,rt as is_encrypted_file,nt as is_encrypted_message,ie as normalize_version,De as scrypt,et as scrypt_hex,h as str_decode,C as str_encode,F as unhexlify};
//# sourceMappingURL=main.bundle.min.js.map
