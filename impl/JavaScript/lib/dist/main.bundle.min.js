var tt=Object.defineProperty;var Ye=(e,t)=>{for(var n in t)tt(e,n,{get:t[n],enumerable:!0})};var Je=new Array(256);for(let e=0;e<256;e++)Je[e]=e.toString(16).padStart(2,"0");function K(e){if(!e||!(e instanceof Uint8Array))throw new TypeError("Input must be a Uint8Array");let t=e.length,n=new Array(t);for(let i=0;i<t;i++)n[i]=Je[e[i]];return n.join("")}var We={get InvalidHexStringException(){throw new TypeError("Invalid hex string")}};function N(e){if(typeof e!="string")throw new TypeError("Input must be a string");let t=e.length;if(t%2!==0)throw new TypeError("Hex string must have even length");e=e.toLowerCase();let n=new Uint8Array(t>>1);for(let i=0;i<t;i+=2){let r=e.charCodeAt(i),o=e.charCodeAt(i+1),a=r>=97&&r<=102?r-87:r>=48&&r<=57?r-48:We.InvalidHexStringException,c=o>=97&&o<=102?o-87:o>=48&&o<=57?o-48:We.InvalidHexStringException;n[i>>1]=a<<4|c}return n}function G(e){let t=new Uint8Array(e);return crypto.getRandomValues(t),t}function nt(){let e=G(1);return new Int8Array(e)[0]}function Ke(){let e=G(1);return new Uint8Array(e)[0]}function T(e,t="utf-8"){if(typeof e!="string")throw new TypeError("Input must be a string");if(t.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextEncoder().encode(e)}function h(e,t="utf-8"){if(e instanceof Uint8Array||(e=new Uint8Array(e)),t.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextDecoder().decode(e)}var Y={};Ye(Y,{BadDataException:()=>B,CannotDecryptException:()=>ae,ChaCha20NotSupportedException:()=>ke,CryptContextNotInitedException:()=>Ie,CryptContextReleasedException:()=>Ne,CryptContextReusedException:()=>ve,DangerousEncryptionAlgorithmException:()=>Ue,DataError:()=>J,DeprecationException:()=>be,EncryptionAlgorithmNotSupportedException:()=>Q,EncryptionError:()=>Ee,EncryptionVersionMismatchException:()=>D,EndOfFileException:()=>Ge,ExpectedError:()=>Be,FileCorruptedException:()=>de,IVException:()=>ge,InputError:()=>oe,InternalError:()=>g,InvalidCryptContextTypeException:()=>De,InvalidEndMarkerException:()=>we,InvalidFileFormatException:()=>ie,InvalidParameterException:()=>l,InvalidScryptParameterException:()=>me,LibraryError:()=>xe,NetworkError:()=>_e,NotSupportedException:()=>H,OperationNotPermittedException:()=>q,ParameterError:()=>$,RuntimeException:()=>le,UnexpectedError:()=>j,UnexpectedFailureInChunkDecryptionException:()=>Ae,UserException:()=>Re,VersionSystemError:()=>Ve,raise:()=>je});var xe=class extends Error{constructor(t="Library Error",n=void 0){super(t,n),this.name="LibraryError"}};function je(e){throw e}var Ee=class extends xe{constructor(t="Encryption Error",n=void 0){super(t,n),this.name="EncryptionError"}},_e=class extends xe{constructor(t="(Network Error)",n=void 0){super(t,n),this.name="NetworkError"}},Be=class extends Ee{constructor(t="(Expected Error)",n=void 0){super(t,n),this.name="ExpectedError"}},le=class extends Ee{constructor(t="(Runtime Error)",n=void 0){super(t,n),this.name="RuntimeException"}},j=class extends le{constructor(t="(Unexpected Error)",n=void 0){super(t,n),this.name="UnexpectedError"}},g=class extends j{constructor(t="(Internal Error)",n=void 0){super(t,n),this.name="InternalError"}},oe=class extends le{constructor(t="(Input Error)",n=void 0){super(t,n),this.name="InputError"}},$=class extends oe{constructor(t="(Data Error)",n=void 0){super(t,n),this.name="ParameterError"}},J=class extends oe{constructor(t="(Data Error)",n=void 0){super(t,n),this.name="DataError"}},Re=class extends le{constructor(t="(The end user has a fault that caused the exception. This is not code bug.)",n=void 0){super(t,n),this.name="UserException"}},Ve=class extends J{constructor(t="(Version System Error)",n=void 0){super(t,n),this.name="VersionSystemError"}},l=class extends ${constructor(t="The parameter provided is invalid.",n=void 0){super(t,n),this.name="InvalidParameterException"}},B=class extends J{constructor(t="The data is bad.",n=void 0){super(t,n),this.name="BadDataException"}},me=class extends ${constructor(t="The N, r, or p is not valid or out of range.",n=void 0){super(t,n),this.name="InvalidScryptParameterException"}},D=class extends Ve{constructor(t="The version of the encryption library doesn't match.",n=void 0){super(t,n),this.name="EncryptionVersionMismatchException"}},ie=class extends J{constructor(t="The file format is invalid.",n=void 0){super(t,n),this.name="InvalidFileFormatException"}},ge=class extends g{constructor(t="IV Exception.",n=void 0){super(t,n),this.name="IVException"}},de=class extends J{constructor(t="File is corrupted.",n=void 0){super(t,n),this.name="FileCorruptedException"}},we=class extends J{constructor(t="The end marker is invalid.",n=void 0){super(t,n),this.name="InvalidEndMarkerException"}},ae=class extends Re{constructor(t="Cannot decrypt",n=void 0){super(t,n),this.name="CannotDecryptException"}},Ae=class extends j{constructor(t="An unexpected failure occurred while decrypting the chunk. The file may be corrupted.",n=void 0){super(t,n),this.name="UnexpectedFailureInChunkDecryptionException"}},ve=class extends ${constructor(t="Not allowed to reuse a crypt context.",n=void 0){super(t,n),this.name="CryptContextReusedException"}},H=class extends oe{constructor(t="Operation not supported",n=void 0){super(t,n),this.name="NotSupportedException"}},be=class extends oe{constructor(t="Trying to use a deprecated feature.",n=void 0){super(t,n),this.name="DeprecationException"}},Ge=class extends Be{constructor(t="End of File",n=void 0){super(t,n),this.name="EndOfFileException",!(typeof process<"u")&&globalThis.console.warn(`%c[npm::simple-data-crypto] %c[EndOfFileException] %cDEPRECATED!! %cDeprecated and will be removed in the next MAJOR version. See %csrc/exceptions.js%c for more information.
%cNote: %cThis %cdoes not%c indicate the package is deprecated. Instead, it indicates that your code uses the %cdeprecated%c class %cEndOfFileException%c. Fix your code to suppress this warning.`,"color: #007700","color: #570263","color: red; font-weight: bold;","","font-weight: bold;","","font-weight: bold; color: #0000ff","","color: red; font-weight: bold;","","font-style: italic","","color: #570263","")}},Ie=class extends ${constructor(t="Crypt context is not initialized.",n=void 0){super(t,n),this.name="CryptContextNotInitedException"}},De=class extends ${constructor(t="Invalid crypt context type.",n=void 0){super(t,n),this.name="InvalidCryptContextTypeException"}},Ne=class extends ${constructor(t="Crypt context has been released.",n=void 0){super(t,n),this.name="CryptContextReleasedException"}},q=class extends ${constructor(t="Operation not permitted.",n=void 0){super(t,n),this.name="OperationNotPermittedException"}},Q=class extends J{constructor(t="The specified encryption algorithm is not supported.",n=void 0){super(t,n),this.name="EncryptionAlgorithmNotSupportedException"}},ke=class extends Q{constructor(t="ChaCha20 is not supported yet.",n=void 0){super(t,n),this.name="ChaCha20NotSupportedException"}},Ue=class extends Q{constructor(t="The specified encryption algorithm is DANGEROUS.",n=void 0){super(t,n),this.name="DangerousEncryptionAlgorithmException"}};function rt(e){return new Promise((t,n)=>{let i=document.createElement("script");i.src=e,i.onload=()=>t(i),i.onerror=r=>n(r),document.head.append(i)})}function He(e,t){return Reflect.has(globalThis,e)?Promise.resolve(Reflect.get(globalThis,e)):rt(t).then(()=>Reflect.get(globalThis,e))}var ee=await He("scrypt",import.meta.resolve("./WebScrypt/scrypt.js"));ee.setResPath(import.meta.resolve("./WebScrypt/asset/"));ee.load();var Ce=function(){let e=[],t=!1,n=r=>new Promise(async(o,a)=>{ee.onprogress=c=>{r.onprogress&&r.onprogress(c)},ee.oncomplete=c=>{r.resolve(c),o(!0)},ee.onerror=c=>{r.reject(c),o(!1)};try{ee.config({N:r.N,r:r.r,P:r.p},{maxPassLen:8192,maxSaltLen:2048,maxDkLen:1024,maxThread:1}),await new Promise(c=>ee.onready=c),ee.hash(r.key,r.salt,r.dklen)}catch(c){a(c)}});async function i(){let r=null;for(;e.length;)try{r=e.splice(0,1)[0],await n(r),await ot()}catch(o){r?.reject(o)}t=!1}return function(o,a,c,u,s,f,p=null){return new Promise((y,A)=>{e.push({key:o,salt:a,N:c,r:u,p:s,dklen:f,resolve:y,reject:A,onprogress:p}),t||(t=!0,setTimeout(i))})}}();function ot(){return new Promise(e=>setTimeout(e))}var b=4096,fe=[85,170,85,170,85,170,85,170],se=[85,170,85,170,85,170,85,170,170,85,170,85,170,85,170,85,85,170,85,170,85,170,85,170,170,85,170,85,170,85,170,85],ce=[85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170],te=[255,253,240,16,19,208,18,24,85,170],Te=2n**64n;if(Te!==BigInt("18446744073709551616"))throw new j("POWER_2_64 is not 2^64");var it=typeof process>"u"?requestAnimationFrame:setTimeout;function ye(){return new Promise(e=>it(e))}function pe(e,t=null){if(!e)return"Unknown Version";let n=String(t);return String(e)==="1.1"&&(n="null"),t?`${e}/${n}`:`${e}/0`}var Z=pe("1.1"),X=pe("1.2",10020);async function W(e){let t=await e(0,13);if(h(t)!=="MyEncryption/")throw new ie;let n=h(await e(13,16));if(!["1.1","1.2"].includes(n))throw new D;let i=new DataView((await e(16,20)).buffer).getUint32(0,!0);return pe(n,i)}async function Se(e){let t=await W(e);if(t===Z)throw new q("The chunk size is volatile and we cannot get a fixed value.");if(t===X){let n=20;n+=b;let i=await e(n,n+4),r=new DataView(i.buffer).getUint32(0,!0);n+=4,n+=r;let o=Number(new DataView((await e(n,n+8)).buffer).getBigUint64(0,!0)),a=Number(new DataView((await e(n+8,n+16)).buffer).getBigUint64(0,!0));return{version:t,chunk_size:o,nonce_counter:a}}throw new D}async function Ze(e){return(await Se(e)).chunk_size}function he(e){if(e&&e!=="AES-GCM")throw e==="ChaCha20"||e==="ChaCha20-Poly1305"?new ke:e==="DES"||e==="RC4"?new Ue:e==="XTS-AES"?new Q("XTS-AES Not supported yet"):new Q(void 0,{cause:new Error(String(e))})}async function at(e){if(typeof e!="string")return!1;if(e.charAt(0)===":"){let t=e.split(":");if(t.length===8){let[,n,i,r,o,a,c]=t;return!!(n&&i&&r&&o&&a&&c)}return!1}if(e.charAt(0)!=="{")return!1;try{let t=JSON.parse(e);return t.data&&t.parameter&&t.N&&t.v}catch{return!1}}async function st(e){try{return!!(await Se(e)).version}catch{return!1}}function ct(e){try{return JSON.parse(e)}catch{throw new l("The JSON is not valid.")}}async function ne(e,t,n=null,i=null){let r=G(12),{derived_key:o,parameter:a,N:c}=await M(t,r,n,i);i=c;let u=await crypto.subtle.importKey("raw",o,"AES-GCM",!1,["encrypt"]);if(typeof e!="string")throw new q("The ability to directly encrypt binary data has been removed in the new version. Please use `encrypt_file` instead.");let s="AES-GCM",f=await crypto.subtle.encrypt({name:s,iv:r},u,T(e)),p=new Uint8Array(r.length+f.byteLength);return p.set(r,0),p.set(new Uint8Array(f),r.length),`:${K(p)}:${a}:${i}:${5.6}:${s}:`}async function F(e,t){let n;if(e.charAt(0)===":"){let d=e.split(":");if(d.length!==8)throw new B("The message is bad.");let[,m,k,O,E,w,R]=d;n={data:m,phrase:k,salt:O,N:+E,v:+w,a:R}}else n=ct(e);let i=parseInt(n.N),r=n.a;he(r);let o=N(n.data),a,c;n.parameter?[a,c]=n.parameter.split(":"):(a=n.phrase,c=n.salt);let u=N(c);if(isNaN(i)||!a||!o||!u)throw new B("The message or parameters are bad.");if(o.length<28)throw new B("The message was too short.");let s=o.slice(0,12),f=o.slice(12,-16),p=o.slice(-16),y=typeof t=="string"?(await M(t,s,a,i,u)).derived_key:t;if(!(y instanceof Uint8Array))throw new l("The key is not valid.");let A=await crypto.subtle.importKey("raw",y,"AES-GCM",!1,["decrypt"]);try{let d=await crypto.subtle.decrypt({name:"AES-GCM",iv:s},A,new Uint8Array([...f,...p]));try{return h(d)}catch{throw new q("The ability to directly decrypt binary data has been removed in the new version. If you have encrypted binary data, please recover it using the old version.")}}catch(d){if(!d||!(d instanceof DOMException))throw new g("Internal error.",{cause:d});let m=d.name;throw m==="InvalidAccessError"?new l("InvalidAccessError.",{cause:d}):m==="OperationError"?new ae("Cannot decrypt. Did you provide the correct password?",{cause:d}):new g("Unexpected error.",{cause:d})}}var Pe=["Furina","Neuvillette","Venti","Nahida","Kinich","Kazuha"];async function M(e,t,n=null,i=null,r=null,o=8,a=1,c=32){if(i===null&&(i=262144),typeof i!="number"||i>2097152||o<1||a<1||typeof o!="number"||typeof a!="number"||typeof c!="number")throw new me;if(typeof e!="string")throw new l("key must be a string");if(!(t instanceof Uint8Array))throw new l("iv must be a Uint8Array");if(n!==null&&typeof n!="string")throw new l("phrase must be a string");if(r||(r=G(64)),n||(n=Pe[Ke()%Pe.length]),n.includes(":"))throw new l('phrase MUST NOT contain ":"');let u=`${n}:${K(r)}`,s=`MyEncryption/1.1 Fontaine/4.2 Iv/${K(t)} user_parameter=${u} user_key=${e}`;return{derived_key:await Ce(T(s),r,i,o,a,c),parameter:u,N:i}}async function pt(e,t){let n=20,i=await W(e);if(i===Z)throw new H("Deriving a key for V1.1 files is not supported");if(i!==X)throw new D;let r=new DataView((await e(n,n+4)).buffer).getUint32(0,!0),o=h(await e(n+4,n+4+r));if(n+=b,r>b)throw new g("(Internal Error) This should not happen. Contact the application developer.");let a=await F(o,t),c=await e(n,n+4),u=new DataView(c.buffer).getUint32(0,!0);n+=4;let s=JSON.parse(h(await e(n,n+u)));n+=u;let f=s.v;if(![5.5].includes(f))throw new D;let[p,y]=s.parameter.split(":"),A=N(y),d=N(s.iv),m=s.N,k=s.a;return he(k),(await M(a,d,p,m,A)).derived_key}async function ut(e,t,n,i,r,o){return K(await Ce(T(e),T(t),n,i,r,o))}async function Xe(e,t,n,i=null,r=null,o=null,a=32*1024*1024){if(!a)throw new l("chunk_size must be greater than 0.");await t(T("MyEncryption/1.2"));let c=10020,u=new ArrayBuffer(4);new DataView(u).setUint32(0,c,!0),await t(new Uint8Array(u));let s=K(G(64)),f=await ne(s,n),p=T(f);if(p.length>b)throw new g("(Internal Error) This should not happen. Contact the application developer.");let y=new ArrayBuffer(4);new DataView(y).setUint32(0,p.length,!0),await t(new Uint8Array(y)),await t(p);let A=new Uint8Array(b-p.length-4).fill(0);await t(A),i?.(0),await ye();let d=G(12),{derived_key:m,parameter:k,N:O}=await M(s,d,r,o);o=O;let E={parameter:k,N:o,v:5.5,a:"AES-GCM",iv:K(d)},w=T(JSON.stringify(E)),R=new ArrayBuffer(4);new DataView(R).setUint32(0,w.length,!0),await t(new Uint8Array(R)),await t(w);let V=new ArrayBuffer(8);new DataView(V).setBigUint64(0,BigInt(a),!0),await t(new Uint8Array(V));let S=0,P=BigInt(1),U=0,C=new ArrayBuffer(8);new DataView(C).setBigUint64(0,P,!0),await t(new Uint8Array(C)),i?.(0);let x=await crypto.subtle.importKey("raw",m,{name:"AES-GCM"},!1,["encrypt"]);for(;;){let I=await e(U,U+a);if(!(I instanceof Uint8Array))throw new B("The file chunk is not a Uint8Array.");if(I.length===0)break;let L=I.length<a,re=new ArrayBuffer(12);if(P>=Te)throw new ge("nonce_counter exceeded the maximum value.");if(new DataView(re).setBigUint64(4,P,!0),P++,L){await t(new Uint8Array(se));let v=new ArrayBuffer(8);new DataView(v).setBigUint64(0,BigInt(I.length),!0),await t(new Uint8Array(v))}let ue=new Uint8Array(re),Me=await crypto.subtle.encrypt({name:"AES-GCM",iv:ue},x,I),Le=new Uint8Array(Me);await t(Le),S+=I.length,U+=I.length,i?.(S)}await t(new Uint8Array(ce));let _=new ArrayBuffer(8);return new DataView(_).setBigUint64(0,BigInt(S),!0),await t(new Uint8Array(_)),await t(new Uint8Array(te)),!0}async function lt(e,t,n,i=null){let r=await e(0,16);if(h(r)!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let o=16,a=await e(o,o+4),c=new DataView(a.buffer).getUint32(0,!0);o+=4;let u=h(await e(o,o+c));o+=1024;let s=await F(u,n),f=await e(o,o+4),p=new DataView(f.buffer).getUint32(0,!0);o+=4;let y=JSON.parse(h(await e(o,o+p)));o+=p;let[A,d]=y.parameter.split(":"),m=N(d),k=N(y.iv),O=y.N;i?.(0),await ye();let{derived_key:E}=await M(s,k,A,O,m),w=0,R=await crypto.subtle.importKey("raw",E,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let U=await e(o,o+8);if(o+=8,U.every((re,ue)=>re===[255,253,240,16,19,208,18,24][ue]))break;let C=Number(new DataView(U.buffer).getBigUint64(0,!0)),x=await e(o,o+12);o+=12;let _=await e(o,o+C+16);o+=C+16;let I=_,L=await crypto.subtle.decrypt({name:"AES-GCM",iv:x},R,I);await t(new Uint8Array(L)),w+=L.byteLength,i&&i(w)}let V=await e(o,o+8),S=Number(new DataView(V.buffer).getBigUint64(0,!0));o+=8;let P=await e(o,o+2);if(w!==S)throw new de("File corrupted: total bytes mismatch");if(!P.every((U,C)=>U===[85,170][C]))throw new we("Invalid end marker");return!0}async function qe(e,t,n,i=null){let r=20;if(await W(e)===Z){if(typeof n!="string")throw new H("operation not supported");return await lt(e,t,n,i)}let a=new DataView((await e(r,r+4)).buffer).getUint32(0,!0),c=h(await e(r+4,r+4+a));if(r+=b,a>b)throw new g("(Internal Error) This should not happen. Contact the application developer.");let u=typeof n=="string"?await F(c,n):null,s=await e(r,r+4),f=new DataView(s.buffer).getUint32(0,!0);r+=4;let p=JSON.parse(h(await e(r,r+f)));r+=f;let y=p.v;if(![5.5].includes(y))throw new D;let[A,d]=p.parameter.split(":"),m=N(d),k=N(p.iv),O=p.N,E=p.a;he(E);let w=Number(new DataView((await e(r,r+8)).buffer).getBigUint64(0,!0)),R=BigInt(new DataView((await e(r+8,r+16)).buffer).getBigUint64(0,!0));r+=16,i?.(0),await ye();let V=typeof n=="string"?u?(await M(u,k,A,O,m)).derived_key:je(new g):n,S=0,P=!1,U=await crypto.subtle.importKey("raw",V,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let I=await e(r,r+8),L=0;if(I.every((v,z)=>v===fe[z])){let v=await e(r,r+32);if(v.every((z,ze)=>z===ce[ze])){r+=32;break}if(v.every((z,ze)=>z===se[ze])){P=!0,r+=32;let z=await e(r,r+8);if(r+=8,L=Number(new DataView(z.buffer).getBigUint64(0,!0)),L===0)break}}let re=P?L:w,ue=new ArrayBuffer(12);new DataView(ue).setBigUint64(4,BigInt(R),!0),R++;let Me=await e(r,r+re+16);r+=re+16;let Le=Me;try{let v=await crypto.subtle.decrypt({name:"AES-GCM",iv:new Uint8Array(ue)},U,Le);await t(new Uint8Array(v)),S+=v.byteLength}catch(v){if(!v||!(v instanceof DOMException))throw new g("Internal error.",{cause:v});let z=v.name;throw z==="InvalidAccessError"?new l("InvalidAccessError.",{cause:v}):z==="OperationError"?new Ae(void 0,{cause:v}):new g("Unexpected error.",{cause:v})}i&&i(S)}let C=await e(r,r+8),x=Number(new DataView(C.buffer).getBigUint64(0,!0));r+=8;let _=await e(r,r+te.length);if(S!==x)throw new de("total bytes mismatch");if(!_.every((I,L)=>I===te[L]))throw new we;return!0}async function dt(e,t){let n=[];if(!await Xe(async(o,a)=>new Uint8Array(await e.slice(o,a).arrayBuffer()),async o=>{n.push(o)},t))throw new j;return new Blob(n)}async function wt(e,t){let n=[];if(!await qe(async(o,a)=>new Uint8Array(await e.slice(o,a).arrayBuffer()),async o=>{n.push(o)},t))throw new j;return new Blob(n)}async function ft(e,t,n){if(!(e instanceof Blob))throw new l;if(typeof t!="string"||typeof n!="string")throw new l;if(e.size<1044)throw new B("Data not enough");let i=await W(async(r,o)=>new Uint8Array(await e.slice(r,o).arrayBuffer()));if(i===Z){let r=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),o=await e.slice(20,20+r).arrayBuffer(),a=h(o);return await ne(await F(a,t),n)}if(i===X){if(e.size<16+b)throw new B("Data not enough");let r=new DataView(await e.slice(20,24).arrayBuffer()).getUint32(0,!0),o=await e.slice(24,24+r).arrayBuffer(),a=h(o);return await ne(await F(a,t),n)}throw new D}async function yt(e,t,n){if(!(e instanceof Blob))throw new l;if(typeof t!="string"||typeof n!="string")throw new l;if(e.size<1044)throw new B("Data not enough");let i=e.slice(0,16);if(await i.text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let o=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),a=h(await e.slice(20,20+o).arrayBuffer()),c=await ne(await F(a,t),n);if(c.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let u=c.length,s=new ArrayBuffer(4);new DataView(s).setUint32(0,u,!0);let p=[i,s,T(c)],y=new Uint8Array(1024-c.length).fill(0);return p.push(y),new Blob(p)}async function ht(e,t,n){if(!(e instanceof Blob))throw new l;if(typeof t!="string"||typeof n!="string")throw new l;if(e.size<1044)throw new B("Data not enough");if(await W(async(y,A)=>new Uint8Array(await e.slice(y,A).arrayBuffer()))===Z)return await yt(e,t,n);let r=new DataView(await e.slice(20,24).arrayBuffer()).getUint32(0,!0),o=h(await e.slice(24,24+r).arrayBuffer()),a=await ne(await F(o,t),n);if(a.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let c=a.length,u=new ArrayBuffer(4);new DataView(u).setUint32(0,c,!0);let f=[e.slice(0,20),u,T(a)],p=new Uint8Array(b-a.length-4).fill(0);return f.push(p),new Blob(f)}var Oe=Object.create(null);Oe[Symbol.toStringTag]="CryptContext";Oe.toString=function(){return`${this[Symbol.toStringTag]} Object`};async function Fe(e){return e instanceof Promise?await e:e}async function xt(){let e=Object.create(Oe);return Object.defineProperty(e,"_created",{value:!0}),e}async function Et(e){if(!e||e._released)throw new l("Invalid context");for(let t of Reflect.ownKeys(e)){if(typeof t=="symbol"){Reflect.deleteProperty(e,t);continue}let n=Reflect.get(e,t);n&&(n.release?await Fe(n.release()):n.free?await Fe(n.free()):n.reset?await Fe(n.reset()):n.clear&&await Fe(n.clear())),t.startsWith("_")||Reflect.deleteProperty(e,t)}return Object.defineProperty(e,"_released",{value:!0}),!0}var $e=class{#n;#e={position:0,end:0,data:null};#t;get[Symbol.toStringTag](){return"Stream"}constructor(t,n){if(typeof t!="function")throw new l("Stream: Invalid reader");if(this.#n=t,typeof n!="number")throw new l("Stream: Invalid size");this.#t=n}get size(){return this.#t}#r=null;async read(t,n,i=null,r=null){if(!this.#n)throw new Error("Stream: The stream has been closed.");if(this.#e.position!=null&&this.#e.end&&this.#e.data&&t>=this.#e.position&&n<=this.#e.end)return this.#e.data.slice(t-this.#e.position,n-this.#e.position);if(t<0)throw new l("Stream: Invalid start position");if(n>this.#t&&(n=this.#t),i!=null&&i>this.#t&&(i=this.#t),this.#r=r,i!=null&&i!==0){let a=await this.#n(t,i,r?.signal);return this.#r=null,this.#e.position=t,this.#e.end=t+a.length,this.#e.data=a,a.slice(0,n-t)}let o=await this.#n(t,n,r?.signal);return this.#r=null,o}abort(){this.#r?.abort()}purge(){this.#e.position=this.#e.end=0,this.#e.data=null}close(){this.#n=null,this.purge()}};async function _t(e,t,n,{cache:i=!0,cache_max_size:r=256*1024*1024}={}){if(e._inited)throw new ve;Object.defineProperty(e,"_inited",{value:!0}),e._type="@decrypt_stream",e.stream={stream:t,release:()=>e.stream.stream.close()};let o=await t.read(0,13,5e3);if(h(o)!=="MyEncryption/")throw new ie;let a=h(await t.read(13,16));if(!["1.1","1.2"].includes(a))throw new D;let c=new DataView((await t.read(16,20)).buffer).getUint32(0,!0),u=pe(a,c),s=20;if(u!==X)throw new H("Cannot perform a streamed decryption on V1.1 files");let f=new DataView((await t.read(s,s+4)).buffer).getUint32(0,!0),p=h(await t.read(s+4,s+4+f));if(s+=b,f>b)throw new g("(Internal Error) This should not happen. Contact the application developer.");let y=await F(p,n),A=await t.read(s,s+4),d=new DataView(A.buffer).getUint32(0,!0);s+=4;let m=JSON.parse(h(await t.read(s,s+d)));s+=d;let k=m.v;if(![5.5].includes(k))throw new D;let[O,E]=m.parameter.split(":"),w=N(E),R=N(m.iv),V=m.N,S=Number(new DataView((await t.read(s,s+8)).buffer).getBigUint64(0,!0)),P=Number(new DataView((await t.read(s+8,s+16)).buffer).getBigUint64(0,!0));s+=16;let{derived_key:U}=await M(y,R,O,V,w),C=await crypto.subtle.importKey("raw",U,{name:"AES-GCM"},!1,["decrypt"]);return e.key=C,e.chunk_size=S,e.nonce_counter=P,e.header_json_length=d,e.cache_enabled=!!i,e.cached_chunks=new Map,e.cached_chunks_add_order=new Array,e.cached_size=0,e.cache_max_size=r,!0}async function mt(e,t,n,i){if(!e._inited)throw new Ie;if(e._type!=="@decrypt_stream")throw new De(e._type);if(e._released)throw new Ne;let r=e.stream.stream,o=e.chunk_size,a=e.nonce_counter,c=[],u=20+b+4+e.header_json_length+8+8,s=o+16,f=Math.floor((r.size-u-(80+te.length))/s),p=Math.max(0,Math.floor(t/o)),y=Math.min(f,Math.floor(n/o));if(y<0||p>f)throw new l("Out of range");let A=async E=>{if(e.cache_enabled&&e.cached_chunks.has(E))return e.cached_chunks.get(E);let w=u+E*s,R=await r.read(w,w+8,w+2*s,i),V=0;if(R.every((x,_)=>x===fe[_])){let x=await r.read(w,w+32,null,i);if(w+=32,x.every((_,I)=>_===ce[I]))return!1;if(x.every((_,I)=>_===se[I])){let _=await r.read(w,w+8,null,i);if(w+=8,V=Number(new DataView(_.buffer).getBigUint64(0,!0)),V===0)return!1}}let S=V||o,P=await r.read(w,w+S+16,null,i),U=a+E,C=new ArrayBuffer(12);new DataView(C).setBigUint64(4,BigInt(U),!0);try{let x=await crypto.subtle.decrypt({name:"AES-GCM",iv:new Uint8Array(C)},e.key,P);if(e.cache_enabled)for(x.byteLength<e.cache_max_size&&(e.cached_chunks_add_order.push(E),e.cached_chunks.set(E,x),e.cached_size+=x.byteLength);e.cached_size>e.cache_max_size;){let _=e.cached_chunks_add_order.shift();e.cached_size-=e.cached_chunks.get(_).byteLength,e.cached_chunks.delete(_)}return x}catch(x){if(!x||!(x instanceof DOMException))throw new g("Internal error.",{cause:x});let _=x.name;throw _==="InvalidAccessError"?new l("InvalidAccessError.",{cause:x}):_==="OperationError"?new ae("Cannot decrypt. Did you provide the correct password?",{cause:x}):new g("Unexpected error.",{cause:x})}},d=!1;for(let E=p;E<=y;E++){let w=await A(E);if(!w){d=!0;break}c.push(w)}let m=new Blob(c),k=p*o,O=m.slice(t-k,n-k);return d&&(O.eof=!0),O}var gt={PADDING_SIZE:b,END_IDENTIFIER:fe,TAIL_BLOCK_MARKER:se,END_MARKER:ce,FILE_END_MARKER:te,nextTick:ye,GetFileVersion:W,GetFileInfo:Se,GetFileChunkSize:Ze,derive_key_default_phrases_list:Pe,POWER_2_64:Te};var et={};Ye(et,{createReaderForFileSystemHandle:()=>At,createReaderForLocalFile:()=>Qe,createReaderForRemoteObject:()=>vt,createWriterForFileSystemHandle:()=>bt,createWriterForMemoryBuffer:()=>It});async function Qe(e){return async(t,n)=>new Uint8Array(await e.slice(t,n).arrayBuffer())}async function At(e){let t=await e.getFile();return await Qe(t)}async function vt(e){return async(t,n)=>{let i=await fetch(e,{headers:{Range:`bytes=${t}-${n-1}`}});if(!i.ok)throw new _e(`Network Error: HTTP ${i.status} : ${i.statusText}`,{response:i});return new Uint8Array(await i.arrayBuffer())}}async function bt(e){throw new be}async function It(e){return async t=>{e.push(t)}}var Dt="Encryption/5.6 FileEncryption/1.2 Patch/56.3 Package/1.56.3";export{Oe as CryptContext,Z as ENCRYPTION_FILE_VER_1_1_0,X as ENCRYPTION_FILE_VER_1_2_10020,Y as Exceptions,$e as InputStream,gt as Internals,Dt as VERSION,et as Wrappers,ht as change_file_password,xt as crypt_context_create,Et as crypt_context_destroy,wt as decrypt_blob,F as decrypt_data,qe as decrypt_file,mt as decrypt_stream,_t as decrypt_stream_init,M as derive_key,pt as derive_key_for_file,dt as encrypt_blob,ne as encrypt_data,Xe as encrypt_file,ft as export_master_key,G as get_random_bytes,nt as get_random_int8_number,Ke as get_random_uint8_number,K as hexlify,st as is_encrypted_file,at as is_encrypted_message,pe as normalize_version,Ce as scrypt,ut as scrypt_hex,h as str_decode,T as str_encode,N as unhexlify};
//# sourceMappingURL=main.bundle.min.js.map
