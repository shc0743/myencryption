var Me=Object.defineProperty;var Fe=(e,t)=>{for(var n in t)Me(e,n,{get:t[n],enumerable:!0})};var Be=new Array(256);for(let e=0;e<256;e++)Be[e]=e.toString(16).padStart(2,"0");function K(e){if(!e||!(e instanceof Uint8Array))throw new TypeError("Input must be a Uint8Array");let t=e.length,n=new Array(t);for(let i=0;i<t;i++)n[i]=Be[e[i]];return n.join("")}var Te={get InvalidHexStringException(){throw new TypeError("Invalid hex string")}};function S(e){if(typeof e!="string")throw new TypeError("Input must be a string");let t=e.length;if(t%2!==0)throw new TypeError("Hex string must have even length");e=e.toLowerCase();let n=new Uint8Array(t>>1);for(let i=0;i<t;i+=2){let r=e.charCodeAt(i),o=e.charCodeAt(i+1),a=r>=97&&r<=102?r-87:r>=48&&r<=57?r-48:Te.InvalidHexStringException,c=o>=97&&o<=102?o-87:o>=48&&o<=57?o-48:Te.InvalidHexStringException;n[i>>1]=a<<4|c}return n}function G(e){let t=new Uint8Array(e);return crypto.getRandomValues(t),t}function Pe(){let e=G(1);return new Int8Array(e)[0]}function Ne(){let e=G(1);return new Uint8Array(e)[0]}function U(e,t="utf-8"){if(typeof e!="string")throw new TypeError("Input must be a string");if(t.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextEncoder().encode(e)}function h(e,t="utf-8"){if(e instanceof Uint8Array||(e=new Uint8Array(e)),t.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextDecoder().decode(e)}var $={};Fe($,{BadDataException:()=>F,CannotDecryptException:()=>Y,ChaCha20NotSupportedException:()=>_e,CryptContextNotInitedException:()=>he,CryptContextReleasedException:()=>xe,CryptContextReusedException:()=>de,DangerousEncryptionAlgorithmException:()=>me,EncryptionAlgorithmNotSupportedException:()=>Z,EncryptionError:()=>x,EncryptionVersionMismatchException:()=>V,EndOfFileException:()=>ke,FileCorruptedException:()=>ce,IVException:()=>ye,InternalError:()=>I,InvalidCryptContextTypeException:()=>fe,InvalidEndMarkerException:()=>pe,InvalidFileFormatException:()=>ee,InvalidParameterException:()=>m,InvalidScryptParameterException:()=>le,NotSupportedException:()=>te,OperationNotPermittedException:()=>J});var x=class extends Error{constructor(t="Encryption Error",n=void 0){super(t,n),this.name="EncryptionError"}},I=class extends x{constructor(t="(Internal Error)",n=void 0){super(t,n),this.name="InternalError"}},m=class extends x{constructor(t="The parameter provided is invalid.",n=void 0){super(t,n),this.name="InvalidParameterException"}},F=class extends x{constructor(t="The data is bad.",n=void 0){super(t,n),this.name="BadDataException"}},le=class extends x{constructor(t="The N, r, or p is not valid or out of range.",n=void 0){super(t,n),this.name="InvalidScryptParameterException"}},V=class extends x{constructor(t="The version of the encryption library doesn't match.",n=void 0){super(t,n),this.name="EncryptionVersionMismatchException"}},ee=class extends x{constructor(t="The file format is invalid.",n=void 0){super(t,n),this.name="InvalidFileFormatException"}},ye=class extends x{constructor(t="IV Exception.",n=void 0){super(t,n),this.name="IVException"}},ce=class extends x{constructor(t="File is corrupted.",n=void 0){super(t,n),this.name="FileCorruptedException"}},pe=class extends x{constructor(t="The end marker is invalid.",n=void 0){super(t,n),this.name="InvalidEndMarkerException"}},Y=class extends x{constructor(t="Cannot decrypt",n=void 0){super(t,n),this.name="CannotDecryptException"}},de=class extends x{constructor(t="Not allowed to reuse a crypt context.",n=void 0){super(t,n),this.name="CryptContextReusedException"}},te=class extends x{constructor(t="Operation not supported",n=void 0){super(t,n),this.name="NotSupportedException"}},ke=class extends x{constructor(t="End of File",n=void 0){super(t,n),this.name="EndOfFileException"}},he=class extends x{constructor(t="Crypt context is not initialized.",n=void 0){super(t,n),this.name="CryptContextNotInitedException"}},fe=class extends x{constructor(t="Invalid crypt context type.",n=void 0){super(t,n),this.name="InvalidCryptContextTypeException"}},xe=class extends x{constructor(t="Crypt context has been released.",n=void 0){super(t,n),this.name="CryptContextReleasedException"}},J=class extends x{constructor(t="Operation not permitted.",n=void 0){super(t,n),this.name="OperationNotPermittedException"}},Z=class extends x{constructor(t="The specified encryption algorithm is not supported.",n=void 0){super(t,n),this.name="EncryptionAlgorithmNotSupportedException"}},_e=class extends Z{constructor(t="ChaCha20 is not supported yet.",n=void 0){super(t,n),this.name="ChaCha20NotSupportedException"}},me=class extends Z{constructor(t="The specified encryption algorithm is DANGEROUS.",n=void 0){super(t,n),this.name="DangerousEncryptionAlgorithmException"}};function Oe(e){return new Promise((t,n)=>{let i=document.createElement("script");i.src=e,i.onload=()=>t(i),i.onerror=r=>n(r),document.head.append(i)})}function Re(e,t){return Reflect.has(globalThis,e)?Promise.resolve(Reflect.get(globalThis,e)):Oe(t).then(()=>Reflect.get(globalThis,e))}var H=await Re("scrypt",import.meta.resolve("./WebScrypt/scrypt.js"));H.setResPath(import.meta.resolve("./WebScrypt/asset/"));H.load();var Ee=function(){let e=[],t=!1,n=r=>new Promise(async(o,a)=>{H.onprogress=c=>{r.onprogress&&r.onprogress(c)},H.oncomplete=c=>{r.resolve(c),o(!0)},H.onerror=c=>{r.reject(c),o(!1)};try{H.config({N:r.N,r:r.r,P:r.p},{maxPassLen:8192,maxSaltLen:2048,maxDkLen:1024,maxThread:1}),await new Promise(c=>H.onready=c),H.hash(r.key,r.salt,r.dklen)}catch(c){a(c)}});async function i(){let r=null;for(;e.length;)try{r=e.splice(0,1)[0],await n(r),await ze()}catch(o){r?.reject(o)}t=!1}return function(o,a,c,w,s,u,p=null){return new Promise((f,v)=>{e.push({key:o,salt:a,N:c,r:w,p:s,dklen:u,resolve:f,reject:v,onprogress:p}),t||(t=!0,setTimeout(i))})}}();function ze(){return new Promise(e=>setTimeout(e))}var Ve=["Furina","Neuvillette","Venti","Nahida","Kinich","Kazuha"];async function j(e,t,n=null,i=null,r=null,o=8,a=1,c=32){if(i===null&&(i=262144),typeof i!="number"||i>2097152)throw new le;if(r||(r=G(64)),n||(n=Ve[Ne()%Ve.length]),n.includes(":"))throw new m('phrase MUST NOT contain ":"');let w=`${n}:${K(r)}`,s=`MyEncryption/1.1 Fontaine/4.2 Iv/${K(t)} user_parameter=${w} user_key=${e}`;return{derived_key:await Ee(U(s),r,i,o,a,c),parameter:w,N:i}}async function Le(e,t,n,i,r,o){return K(await Ee(U(e),U(t),n,i,r,o))}var N=4096,ue=[85,170,85,170,85,170,85,170],ne=[85,170,85,170,85,170,85,170,170,85,170,85,170,85,170,85,85,170,85,170,85,170,85,170,170,85,170,85,170,85,170,85],re=[85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170],X=[255,253,240,16,19,208,18,24,85,170],Ke=typeof process>"u"?requestAnimationFrame:setTimeout;function we(){return new Promise(e=>Ke(e))}function oe(e,t){return e?(String(e)==="1.1"&&(t=null),t?`${e}/${t}`:`${e}/0`):"Unknown Version"}var ie=oe("1.1"),ae=oe("1.2",10020);async function W(e){let t=await e(0,13);if(h(t)!=="MyEncryption/")throw new ee;let n=h(await e(13,16));if(!["1.1","1.2"].includes(n))throw new V;let i=new DataView((await e(16,20)).buffer).getUint32(0,!0);return oe(n,i)}async function De(e){let t=await W(e);if(t===ie)throw new J("The chunk size is volatile and we cannot get a fixed value.");if(t===ae){let n=20;n+=N;let i=await e(n,n+4),r=new DataView(i.buffer).getUint32(0,!0);n+=4,n+=r;let o=Number(new DataView((await e(n,n+8)).buffer).getBigUint64(0,!0)),a=Number(new DataView((await e(n+8,n+16)).buffer).getBigUint64(0,!0));return{version:t,chunk_size:o,nonce_counter:a}}throw new V}async function Se(e){return(await De(e)).chunk_size}function Ae(e){if(e&&e!=="AES-GCM")throw e==="ChaCha20"||e==="ChaCha20-Poly1305"?new _e:e==="DES"||e==="RC4"?new me:e==="XTS-AES"?new Z("XTS-AES Not supported yet"):new Z(void 0,{cause:new Error(String(e))})}function Ge(e){try{return JSON.parse(e)}catch{throw new m("The JSON is not valid.")}}async function q(e,t,n=null,i=null){let r=G(12),{derived_key:o,parameter:a,N:c}=await j(t,r,n,i);i=c;let w=await crypto.subtle.importKey("raw",o,"AES-GCM",!1,["encrypt"]);if(typeof e!="string")throw new J("The ability to directly encrypt binary data has been removed in the new version. Please use `encrypt_file` instead.");let s=await crypto.subtle.encrypt({name:"AES-GCM",iv:r},w,U(e)),u=new Uint8Array(r.length+s.byteLength);u.set(r,0),u.set(new Uint8Array(s),r.length);let p=K(u);return JSON.stringify({data:p,parameter:a,N:i,v:5.6,a:"AES-GCM"})}async function P(e,t){let n=Ge(e),i=n.parameter,r=parseInt(n.N),o=n.a;Ae(o);let a=S(n.data),[c,w]=i.split(":"),s=S(w);if(isNaN(r)||!i||!a||!s)throw new F("The message or parameters are bad.");if(a.length<28)throw new F("The message was too short.");let u=a.slice(0,12),p=a.slice(12,-16),f=a.slice(-16),v=typeof t=="string"?(await j(t,u,c,r,s)).derived_key:t,b=await crypto.subtle.importKey("raw",v,"AES-GCM",!1,["decrypt"]);try{let d=await crypto.subtle.decrypt({name:"AES-GCM",iv:u},b,new Uint8Array([...p,...f]));try{return h(d)}catch{throw new J("The ability to directly decrypt binary data has been removed in the new version. If you have encrypted binary data, please recover it using the old version.")}}catch(d){if(!d)throw new I("Internal error.",{cause:d});let T=d.name;if(T==="InvalidAccessError")throw new m("InvalidAccessError.",{cause:d});if(T==="OperationError")throw new Y("Cannot decrypt. Did you provide the correct password?",{cause:d});if(!d)throw new I("Unexpected error.",{cause:d})}}async function je(e,t,n,i=null,r=null,o=null,a=32*1024*1024){if(!a)throw new m("chunk_size must be greater than 0.");await t(U("MyEncryption/1.2"));let c=10020,w=new ArrayBuffer(4);new DataView(w).setUint32(0,c,!0),await t(new Uint8Array(w));let s=K(G(64)),u=await q(s,n),p=U(u);if(p.length>N)throw new I("(Internal Error) This should not happen. Contact the application developer.");let f=new ArrayBuffer(4);new DataView(f).setUint32(0,p.length,!0),await t(new Uint8Array(f)),await t(p);let v=new Uint8Array(N-p.length-4).fill(0);await t(v),i?.(0),await we();let b=G(12),{derived_key:d,parameter:T,N:O}=await j(s,b,r,o);o=O;let E={parameter:T,N:o,v:5.5,a:"AES-GCM",iv:K(b)},l=U(JSON.stringify(E)),M=new ArrayBuffer(4);new DataView(M).setUint32(0,l.length,!0),await t(new Uint8Array(M)),await t(l);let B=new ArrayBuffer(8);new DataView(B).setBigUint64(0,BigInt(a),!0),await t(new Uint8Array(B));let R=0,k=1,D=0,C=new ArrayBuffer(8);new DataView(C).setBigUint64(0,BigInt(k),!0),await t(new Uint8Array(C)),i?.(0);let y=await crypto.subtle.importKey("raw",d,{name:"AES-GCM"},!1,["encrypt"]);for(;;){let g=await e(D,D+a);if(!(g instanceof Uint8Array))throw new F("The file chunk is not a Uint8Array.");if(g.length===0)break;let z=g.length<a,Q=new ArrayBuffer(12);if(k>=2**64||k>=Number.MAX_SAFE_INTEGER)throw new ye("nonce_counter exceeded the maximum value.");if(new DataView(Q).setBigUint64(4,BigInt(k),!0),k++,z){await t(new Uint8Array(ne));let A=new ArrayBuffer(8);new DataView(A).setBigUint64(0,BigInt(g.length),!0),await t(new Uint8Array(A))}let se=new Uint8Array(Q),ve=await crypto.subtle.encrypt({name:"AES-GCM",iv:se},y,g),be=new Uint8Array(ve);await t(be),R+=g.length,D+=g.length,i?.(R)}await t(new Uint8Array(re));let _=new ArrayBuffer(8);return new DataView(_).setBigUint64(0,BigInt(R),!0),await t(new Uint8Array(_)),await t(new Uint8Array(X)),!0}async function Ye(e,t,n,i=null){let r=await e(0,16);if(h(r)!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let o=16,a=await e(o,o+4),c=new DataView(a.buffer).getUint32(0,!0);o+=4;let w=h(await e(o,o+c));o+=1024;let s=await P(w,n),u=await e(o,o+4),p=new DataView(u.buffer).getUint32(0,!0);o+=4;let f=JSON.parse(h(await e(o,o+p)));o+=p;let[v,b]=f.parameter.split(":"),d=S(b),T=S(f.iv),O=f.N;i?.(0),await we();let{derived_key:E}=await j(s,T,v,O,d),l=0,M=await crypto.subtle.importKey("raw",E,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let D=await e(o,o+8);if(o+=8,D.every((Q,se)=>Q===[255,253,240,16,19,208,18,24][se]))break;let C=Number(new DataView(D.buffer).getBigUint64(0,!0)),y=await e(o,o+12);o+=12;let _=await e(o,o+C+16);o+=C+16;let g=_,z=await crypto.subtle.decrypt({name:"AES-GCM",iv:y},M,g);await t(new Uint8Array(z)),l+=z.byteLength,i&&i(l)}let B=await e(o,o+8),R=Number(new DataView(B.buffer).getBigUint64(0,!0));o+=8;let k=await e(o,o+2);if(l!==R)throw new ce("File corrupted: total bytes mismatch");if(!k.every((D,C)=>D===[85,170][C]))throw new pe("Invalid end marker");return!0}async function $e(e,t,n,i=null){let r=20;if(await W(e)===ie){if(typeof n!="string")throw new te("operation not supported");return await Ye(e,t,n,i)}let a=new DataView((await e(r,r+4)).buffer).getUint32(0,!0),c=h(await e(r+4,r+4+a));if(r+=N,a>N)throw new I("(Internal Error) This should not happen. Contact the application developer.");let w=typeof n=="string"?await P(c,n):null,s=await e(r,r+4),u=new DataView(s.buffer).getUint32(0,!0);r+=4;let p=JSON.parse(h(await e(r,r+u)));r+=u;let f=p.v;if(![5.5].includes(f))throw new V;let[v,b]=p.parameter.split(":"),d=S(b),T=S(p.iv),O=p.N,E=p.a;Ae(E);let l=Number(new DataView((await e(r,r+8)).buffer).getBigUint64(0,!0)),M=Number(new DataView((await e(r+8,r+16)).buffer).getBigUint64(0,!0));r+=16,i?.(0),await we();let B=typeof n=="string"?(await j(w,T,v,O,d)).derived_key:n,R=0,k=!1,D=await crypto.subtle.importKey("raw",B,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let g=await e(r,r+8),z=0;if(g.every((A,L)=>A===ue[L])){let A=await e(r,r+32);if(A.every((L,Ie)=>L===re[Ie])){r+=32;break}if(A.every((L,Ie)=>L===ne[Ie])){k=!0,r+=32;let L=await e(r,r+8);if(r+=8,z=Number(new DataView(L.buffer).getBigUint64(0,!0)),z===0)break}}let Q=k?z:l,se=new ArrayBuffer(12);new DataView(se).setBigUint64(4,BigInt(M),!0),M++;let ve=await e(r,r+Q+16);r+=Q+16;let be=ve;try{let A=await crypto.subtle.decrypt({name:"AES-GCM",iv:new Uint8Array(se)},D,be);await t(new Uint8Array(A)),R+=A.byteLength}catch(A){if(!A)throw new I("Internal error.",{cause:A});let L=A.name;if(L==="InvalidAccessError")throw new m("InvalidAccessError.",{cause:A});if(L==="OperationError")throw new Y("Cannot decrypt. Did you provide the correct password?",{cause:A});if(!A)throw new I("Unexpected error.",{cause:A})}i&&i(R)}let C=await e(r,r+8),y=Number(new DataView(C.buffer).getBigUint64(0,!0));r+=8;let _=await e(r,r+X.length);if(R!==y)throw new ce("total bytes mismatch");if(!_.every((g,z)=>g===X[z]))throw new pe;return!0}async function Je(e,t,n){if(e.size<1044)throw new F("Data not enough");let i=await W(async(r,o)=>new Uint8Array(await e.slice(r,o).arrayBuffer()));if(i===ie){let r=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),o=await e.slice(20,20+r).arrayBuffer(),a=h(o);return await q(await P(a,t),n)}if(i===ae){if(e.size<16+N)throw new F("Data not enough");let r=new DataView(await e.slice(20,24).arrayBuffer()).getUint32(0,!0),o=await e.slice(24,24+r).arrayBuffer(),a=h(o);return await q(await P(a,t),n)}throw new V}async function Ze(e,t,n){if(e.size<1044)throw new Error("Data not enough");let i=e.slice(0,16);if(await i.text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let o=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),a=h(await e.slice(20,20+o).arrayBuffer()),c=await q(await P(a,t),n);if(c.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let w=c.length,s=new ArrayBuffer(4);new DataView(s).setUint32(0,w,!0);let p=[i,s,U(c)],f=new Uint8Array(1024-c.length).fill(0);return p.push(f),new Blob(p)}async function He(e,t,n){if(e.size<1044)throw new Error("Data not enough");if(await W(async(f,v)=>new Uint8Array(await e.slice(f,v).arrayBuffer()))===ie)return await Ze(e,t,n);let r=new DataView(await e.slice(20,24).arrayBuffer()).getUint32(0,!0),o=h(await e.slice(24,24+r).arrayBuffer()),a=await q(await P(o,t),n);if(a.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let c=a.length,w=new ArrayBuffer(4);new DataView(w).setUint32(0,c,!0);let u=[e.slice(0,20),w,U(a)],p=new Uint8Array(N-a.length-4).fill(0);return u.push(p),new Blob(u)}var Ce=Object.create(null);Ce[Symbol.toStringTag]="CryptContext";Ce.toString=function(){return`${this[Symbol.toStringTag]} Object`};async function ge(e){return e instanceof Promise?await e:e}async function Xe(){let e=Object.create(Ce);return Object.defineProperty(e,"_created",{value:!0}),e}async function We(e){if(!e||e._released)throw new m("Invalid context");for(let t of Reflect.ownKeys(e)){if(typeof t=="symbol"){Reflect.deleteProperty(e,t);continue}let n=Reflect.get(e,t);n&&(n.release?await ge(n.release()):n.free?await ge(n.free()):n.reset?await ge(n.reset()):n.clear&&await ge(n.clear())),t.startsWith("_")||Reflect.deleteProperty(e,t)}return Object.defineProperty(e,"_released",{value:!0}),!0}var Ue=class{#n=null;#e={position:null,end:null,data:null};#t=null;get[Symbol.toStringTag](){return"Stream"}constructor(t,n){if(typeof t!="function")throw new m("Stream: Invalid reader");if(this.#n=t,typeof n!="number")throw new m("Stream: Invalid size");this.#t=n}get size(){return this.#t}#r=null;async read(t,n,i=null,r=null){if(!this.#n)throw new Error("Stream: The stream has been closed.");if(this.#e.position!=null&&this.#e.end&&this.#e.data&&t>=this.#e.position&&n<=this.#e.end)return this.#e.data.slice(t-this.#e.position,n-this.#e.position);if(t<0)throw new m("Stream: Invalid start position");if(n>this.#t&&(n=this.#t),i>this.#t&&(i=this.#t),this.#r=r,i){let a=await this.#n(t,i,r?.signal);return this.#r=null,this.#e.position=t,this.#e.end=t+a.length,this.#e.data=a,a.slice(0,n-t)}let o=await this.#n(t,n,r?.signal);return this.#r=null,o}abort(){this.#r?.abort()}purge(){this.#e.position=this.#e.data=this.#e.end=null}close(){this.#n=null,this.purge()}};async function qe(e,t,n,{cache:i=!0,cache_max_size:r=256*1024*1024}={}){if(e._inited)throw new de;Object.defineProperty(e,"_inited",{value:!0}),e._type="@decrypt_stream",e.stream={stream:t,release:()=>e.stream.stream.close()};let o=await t.read(0,13,5e3);if(h(o)!=="MyEncryption/")throw new ee;let a=h(await t.read(13,16));if(!["1.1","1.2"].includes(a))throw new V;let c=new DataView((await t.read(16,20)).buffer).getUint32(0,!0),w=oe(a,c),s=20;if(w!==ae)throw new te("Cannot perform a streamed decryption on V1.1 files");let u=new DataView((await t.read(s,s+4)).buffer).getUint32(0,!0),p=h(await t.read(s+4,s+4+u));if(s+=N,u>N)throw new I("(Internal Error) This should not happen. Contact the application developer.");let f=await P(p,n),v=await t.read(s,s+4),b=new DataView(v.buffer).getUint32(0,!0);s+=4;let d=JSON.parse(h(await t.read(s,s+b)));s+=b;let T=d.v;if(![5.5].includes(T))throw new V;let[O,E]=d.parameter.split(":"),l=S(E),M=S(d.iv),B=d.N,R=Number(new DataView((await t.read(s,s+8)).buffer).getBigUint64(0,!0)),k=Number(new DataView((await t.read(s+8,s+16)).buffer).getBigUint64(0,!0));s+=16;let{derived_key:D}=await j(f,M,O,B,l),C=await crypto.subtle.importKey("raw",D,{name:"AES-GCM"},!1,["decrypt"]);return e.key=C,e.chunk_size=R,e.nonce_counter=k,e.header_json_length=b,e.cache_enabled=!!i,e.cached_chunks=new Map,e.cached_chunks_add_order=new Array,e.cached_size=0,e.cache_max_size=r,!0}async function Qe(e,t,n,i){if(!e._inited)throw new he;if(e._type!=="@decrypt_stream")throw new fe(e._type);if(e._released)throw new xe;let r=e.stream.stream,o=e.chunk_size,a=e.nonce_counter,c=[],w=20+N+4+e.header_json_length+8+8,s=o+16,u=Math.floor((r.size-w-(80+X.length))/s),p=Math.max(0,Math.floor(t/o)),f=Math.min(u,Math.floor(n/o));if(f<0||p>u)throw new m("Out of range");let v=async E=>{if(e.cache_enabled&&e.cached_chunks.has(E))return e.cached_chunks.get(E);let l=w+E*s,M=await r.read(l,l+8,l+2*s,i),B=0;if(M.every((y,_)=>y===ue[_])){let y=await r.read(l,l+32,null,i);if(l+=32,y.every((_,g)=>_===re[g]))return!1;if(y.every((_,g)=>_===ne[g])){let _=await r.read(l,l+8,null,i);if(l+=8,B=Number(new DataView(_.buffer).getBigUint64(0,!0)),B===0)return!1}}let R=B||o,k=await r.read(l,l+R+16,null,i),D=a+E,C=new ArrayBuffer(12);new DataView(C).setBigUint64(4,BigInt(D),!0);try{let y=await crypto.subtle.decrypt({name:"AES-GCM",iv:new Uint8Array(C)},e.key,k);if(e.cache_enabled)for(y.byteLength<e.cache_max_size&&(e.cached_chunks_add_order.push(E),e.cached_chunks.set(E,y),e.cached_size+=y.byteLength);e.cached_size>e.cache_max_size;){let _=e.cached_chunks_add_order.shift();e.cached_size-=e.cached_chunks.get(_).byteLength,e.cached_chunks.delete(_)}return y}catch(y){if(!y)throw new I("Internal error.",{cause:y});let _=y.name;if(_==="InvalidAccessError")throw new m("InvalidAccessError.",{cause:y});if(_==="OperationError")throw new Y("Cannot decrypt. Did you provide the correct password?",{cause:y});if(!y)throw new I("Unexpected error.",{cause:y})}},b=!1;for(let E=p;E<=f;E++){let l=await v(E);if(!l){b=!0;break}c.push(l)}let d=new Blob(c),T=p*o,O=d.slice(t-T,n-T);return b&&(O.eof=!0),O}var et={PADDING_SIZE:N,END_IDENTIFIER:ue,TAIL_BLOCK_MARKER:ne,END_MARKER:re,FILE_END_MARKER:X,nextTick:we,GetFileVersion:W,GetFileInfo:De,GetFileChunkSize:Se};var tt="Encryption/5.6 FileEncryption/1.2 Patch/5.6 Package/1.3.56";export{ie as ENCRYPTION_FILE_VER_1_1_0,ae as ENCRYPTION_FILE_VER_1_2_10020,$ as Exceptions,et as Internals,Ue as Stream,tt as VERSION,He as change_file_password,Xe as crypt_context_create,We as crypt_context_destroy,P as decrypt_data,$e as decrypt_file,Qe as decrypt_stream,qe as decrypt_stream_init,j as derive_key,q as encrypt_data,je as encrypt_file,Je as export_master_key,G as get_random_bytes,Pe as get_random_int8_number,Ne as get_random_uint8_number,K as hexlify,oe as normalize_version,Ee as scrypt,Le as scrypt_hex,h as str_decode,U as str_encode,S as unhexlify};
//# sourceMappingURL=main.bundle.min.js.map
