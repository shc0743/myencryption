var it=Object.defineProperty;var He=(e,t)=>{for(var n in t)it(e,n,{get:t[n],enumerable:!0})};var Xe=new Array(256);for(let e=0;e<256;e++)Xe[e]=e.toString(16).padStart(2,"0");function K(e){if(!e||!(e instanceof Uint8Array))throw new TypeError("Input must be a Uint8Array");let t=e.length,n=new Array(t);for(let o=0;o<t;o++)n[o]=Xe[e[o]];return n.join("")}var Ze={get InvalidHexStringException(){throw new TypeError("Invalid hex string")}};function N(e){if(typeof e!="string")throw new TypeError("Input must be a string");let t=e.length;if(t%2!==0)throw new TypeError("Hex string must have even length");e=e.toLowerCase();let n=new Uint8Array(t>>1);for(let o=0;o<t;o+=2){let r=e.charCodeAt(o),i=e.charCodeAt(o+1),a=r>=97&&r<=102?r-87:r>=48&&r<=57?r-48:Ze.InvalidHexStringException,c=i>=97&&i<=102?i-87:i>=48&&i<=57?i-48:Ze.InvalidHexStringException;n[o>>1]=a<<4|c}return n}var at=globalThis.crypto;function G(e){let t=new Uint8Array(e);return at.getRandomValues(t),t}function st(){let e=G(1);return new Int8Array(e)[0]}function je(){let e=G(1);return new Uint8Array(e)[0]}function C(e,t="utf-8"){if(typeof e!="string")throw new TypeError("Input must be a string");if(t.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextEncoder().encode(e)}function f(e,t="utf-8"){if(e instanceof Uint8Array||(e=new Uint8Array(e)),t.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextDecoder().decode(e)}var H={};He(H,{BadDataException:()=>D,CannotDecryptException:()=>ae,ChaCha20NotSupportedException:()=>Ne,CryptContextNotInitedException:()=>Ie,CryptContextReleasedException:()=>ke,CryptContextReusedException:()=>ve,DangerousEncryptionAlgorithmException:()=>Be,DataError:()=>J,DeprecationException:()=>$e,EncryptionAlgorithmNotSupportedException:()=>Q,EncryptionError:()=>_e,EncryptionVersionMismatchException:()=>k,EndOfFileException:()=>Ye,ExpectedError:()=>Ce,FileCorruptedException:()=>we,IVException:()=>Ae,InputError:()=>oe,InternalError:()=>m,InvalidCryptContextTypeException:()=>De,InvalidEndMarkerException:()=>fe,InvalidFileFormatException:()=>ie,InvalidParameterException:()=>w,InvalidScryptParameterException:()=>ge,LibraryError:()=>Ee,NetworkError:()=>me,NotSupportedException:()=>W,OperationNotPermittedException:()=>q,ParameterError:()=>$,RuntimeException:()=>le,UnexpectedError:()=>j,UnexpectedFailureInChunkDecryptionException:()=>be,UserException:()=>Re,VersionSystemError:()=>Ve,raise:()=>Je});var Ee=class extends Error{constructor(t="Library Error",n=void 0){super(t,n),this.name="LibraryError"}};function Je(e){throw e}var _e=class extends Ee{constructor(t="Encryption Error",n=void 0){super(t,n),this.name="EncryptionError"}},me=class extends Ee{constructor(t="(Network Error)",n=void 0){super(t,n),this.name="NetworkError"}},Ce=class extends _e{constructor(t="(Expected Error)",n=void 0){super(t,n),this.name="ExpectedError"}},le=class extends _e{constructor(t="(Runtime Error)",n=void 0){super(t,n),this.name="RuntimeException"}},j=class extends le{constructor(t="(Unexpected Error)",n=void 0){super(t,n),this.name="UnexpectedError"}},m=class extends j{constructor(t="(Internal Error)",n=void 0){super(t,n),this.name="InternalError"}},oe=class extends le{constructor(t="(Input Error)",n=void 0){super(t,n),this.name="InputError"}},$=class extends oe{constructor(t="(Data Error)",n=void 0){super(t,n),this.name="ParameterError"}},J=class extends oe{constructor(t="(Data Error)",n=void 0){super(t,n),this.name="DataError"}},Re=class extends le{constructor(t="(The end user has a fault that caused the exception. This is not code bug.)",n=void 0){super(t,n),this.name="UserException"}},Ve=class extends J{constructor(t="(Version System Error)",n=void 0){super(t,n),this.name="VersionSystemError"}},w=class extends ${constructor(t="The parameter provided is invalid.",n=void 0){super(t,n),this.name="InvalidParameterException"}},D=class extends J{constructor(t="The data is bad.",n=void 0){super(t,n),this.name="BadDataException"}},ge=class extends ${constructor(t="The N, r, or p is not valid or out of range.",n=void 0){super(t,n),this.name="InvalidScryptParameterException"}},k=class extends Ve{constructor(t="The version of the encryption library doesn't match.",n=void 0){super(t,n),this.name="EncryptionVersionMismatchException"}},ie=class extends J{constructor(t="The file format is invalid.",n=void 0){super(t,n),this.name="InvalidFileFormatException"}},Ae=class extends m{constructor(t="IV Exception.",n=void 0){super(t,n),this.name="IVException"}},we=class extends J{constructor(t="File is corrupted.",n=void 0){super(t,n),this.name="FileCorruptedException"}},fe=class extends J{constructor(t="The end marker is invalid.",n=void 0){super(t,n),this.name="InvalidEndMarkerException"}},ae=class extends Re{constructor(t="Cannot decrypt",n=void 0){super(t,n),this.name="CannotDecryptException"}},be=class extends j{constructor(t="An unexpected failure occurred while decrypting the chunk. The file may be corrupted.",n=void 0){super(t,n),this.name="UnexpectedFailureInChunkDecryptionException"}},ve=class extends ${constructor(t="Not allowed to reuse a crypt context.",n=void 0){super(t,n),this.name="CryptContextReusedException"}},W=class extends oe{constructor(t="Operation not supported",n=void 0){super(t,n),this.name="NotSupportedException"}},$e=class extends oe{constructor(t="Trying to use a deprecated feature.",n=void 0){super(t,n),this.name="DeprecationException"}},Ye=class extends Ce{constructor(t="End of File",n=void 0){super(t,n),this.name="EndOfFileException",!(typeof process<"u")&&globalThis.console.warn(`%c[npm::simple-data-crypto] %c[EndOfFileException] %cDEPRECATED!! %cDeprecated and will be removed in the next MAJOR version. See %csrc/exceptions.js%c for more information.
%cNote: %cThis %cdoes not%c indicate the package is deprecated. Instead, it indicates that your code uses the %cdeprecated%c class %cEndOfFileException%c. Fix your code to suppress this warning.`,"color: #007700","color: #570263","color: red; font-weight: bold;","","font-weight: bold;","","font-weight: bold; color: #0000ff","","color: red; font-weight: bold;","","font-style: italic","","color: #570263","")}},Ie=class extends ${constructor(t="Crypt context is not initialized.",n=void 0){super(t,n),this.name="CryptContextNotInitedException"}},De=class extends ${constructor(t="Invalid crypt context type.",n=void 0){super(t,n),this.name="InvalidCryptContextTypeException"}},ke=class extends ${constructor(t="Crypt context has been released.",n=void 0){super(t,n),this.name="CryptContextReleasedException"}},q=class extends ${constructor(t="Operation not permitted.",n=void 0){super(t,n),this.name="OperationNotPermittedException"}},Q=class extends J{constructor(t="The specified encryption algorithm is not supported.",n=void 0){super(t,n),this.name="EncryptionAlgorithmNotSupportedException"}},Ne=class extends Q{constructor(t="ChaCha20 is not supported yet.",n=void 0){super(t,n),this.name="ChaCha20NotSupportedException"}},Be=class extends Q{constructor(t="The specified encryption algorithm is DANGEROUS.",n=void 0){super(t,n),this.name="DangerousEncryptionAlgorithmException"}};function ct(e){return new Promise((t,n)=>{let o=document.createElement("script");o.src=e,o.onload=()=>t(o),o.onerror=r=>n(r),document.head.append(o)})}function qe(e,t){return Reflect.has(globalThis,e)?Promise.resolve(Reflect.get(globalThis,e)):ct(t).then(()=>Reflect.get(globalThis,e))}var ee=await qe("scrypt",import.meta.resolve("./WebScrypt/scrypt.js"));ee.setResPath(import.meta.resolve("./WebScrypt/asset/"));ee.load();var Te=function(){let e=[],t=!1,n=r=>new Promise(async(i,a)=>{ee.onprogress=c=>{r.onprogress&&r.onprogress(c)},ee.oncomplete=c=>{r.resolve(c),i(!0)},ee.onerror=c=>{r.reject(c),i(!1)};try{ee.config({N:r.N,r:r.r,P:r.p},{maxPassLen:8192,maxSaltLen:2048,maxDkLen:1024,maxThread:1}),await new Promise(c=>ee.onready=c),ee.hash(r.key,r.salt,r.dklen)}catch(c){a(c)}});async function o(){let r=null;for(;e.length;)try{r=e.splice(0,1)[0],await n(r),await pt()}catch(i){r?.reject(i)}t=!1}return function(i,a,c,u,s,p,l=null){return new Promise((d,g)=>{e.push({key:i,salt:a,N:c,r:u,p:s,dklen:p,resolve:d,reject:g,onprogress:l}),t||(t=!0,setTimeout(o))})}}();function pt(){return new Promise(e=>setTimeout(e))}var v=4096,de=[85,170,85,170,85,170,85,170],se=[85,170,85,170,85,170,85,170,170,85,170,85,170,85,170,85,85,170,85,170,85,170,85,170,170,85,170,85,170,85,170,85],ce=[85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170],te=[255,253,240,16,19,208,18,24,85,170],Ue=2n**64n;if(Ue!==BigInt("18446744073709551616"))throw new j("POWER_2_64 is not 2^64");var ut=typeof process>"u"?requestAnimationFrame:setTimeout;function he(){return new Promise(e=>ut(e))}function pe(e,t=null){if(!e)return"Unknown Version";let n=String(t);return String(e)==="1.1"&&(n="null"),t?`${e}/${n}`:`${e}/0`}var Z=pe("1.1"),X=pe("1.2",10020);async function Y(e){let t=await e(0,13);if(f(t)!=="MyEncryption/")throw new ie;let n=f(await e(13,16));if(!["1.1","1.2"].includes(n))throw new k;let o=new DataView((await e(16,20)).buffer).getUint32(0,!0);return pe(n,o)}async function Pe(e){let t=await Y(e);if(t===Z)throw new q("The chunk size is volatile and we cannot get a fixed value.");if(t===X){let n=20,o=new DataView((await e(n,n+4)).buffer).getUint32(0,!0),r=f(await e(n+4,n+4+o));n+=v;let i=await e(n,n+4),a=new DataView(i.buffer).getUint32(0,!0);n+=4,n+=a;let c=Number(new DataView((await e(n,n+8)).buffer).getBigUint64(0,!0)),u=Number(new DataView((await e(n+8,n+16)).buffer).getBigUint64(0,!0));return{version:t,chunk_size:c,nonce_counter:u,ekey:r}}throw new k}async function Qe(e){return(await Pe(e)).chunk_size}function ye(e){if(e&&e!=="AES-GCM")throw e==="ChaCha20"||e==="ChaCha20-Poly1305"?new Ne:e==="DES"||e==="RC4"?new Be:e==="XTS-AES"?new Q("XTS-AES is not supported yet"):new Q(void 0,{cause:new Error(String(e))})}async function lt(e){if(typeof e!="string")return!1;if(e.charAt(0)===":"){let t=e.split(":");if(t.length===8){let[,n,o,r,i,a,c]=t;return!!(n&&o&&r&&i&&a&&c)}return!1}if(e.charAt(0)!=="{")return!1;try{let t=JSON.parse(e);return t.data&&t.parameter&&t.N&&t.v}catch{return!1}}async function wt(e){try{return!!(await Pe(e)).version}catch{return!1}}var Se=globalThis.crypto;function ft(e){try{let t=JSON.parse(e);if(!t||!t.data||!t.parameter||!t.N||!t.v)throw new D("The message is bad since the JSON is not complete.");return t}catch{throw new D("The message is bad since it is neither a JSON or a new-format ciphertext.")}}async function ne(e,t,n=null,o=null){let r=G(12),{derived_key:i,parameter:a,N:c}=await M(t,r,n,o);o=c;let u=await Se.subtle.importKey("raw",i,"AES-GCM",!1,["encrypt"]);if(typeof e!="string")throw new q("The ability to directly encrypt binary data has been removed in the new version. Please use `encrypt_file` instead.");let s="AES-GCM",p=await Se.subtle.encrypt({name:s,iv:r},u,C(e)),l=new Uint8Array(r.length+p.byteLength);return l.set(r,0),l.set(new Uint8Array(p),r.length),`:${K(l)}:${a}:${o}:${5.6}:${s}:`}async function Fe(e){if(typeof e!="string")throw new w("The message is not a string.");let t;if(e.charAt(0)===":"){let l=e.split(":");if(l.length!==8)throw new D("The message is bad.");let[,d,g,x,E,B,F]=l;t={data:d,phrase:g,salt:x,N:+E,v:+B,a:F}}else t=ft(e);let n=parseInt(t.N),o=t.a;ye(o);let r=N(t.data),i,a;t.parameter?[i,a]=t.parameter.split(":"):(i=t.phrase,a=t.salt);let c=N(a);if(isNaN(n)||!i||typeof i!="string"||!r||!c)throw new D("The message or parameters are bad.");if(r.length<28)throw new D("The message was too short.");let u=r.slice(0,12),s=r.slice(12,-16),p=r.slice(-16);return{iv:u,ciphertext:s,tag:p,phrase:i,salt:c,N:n}}async function S(e,t){let{iv:n,ciphertext:o,tag:r,phrase:i,salt:a,N:c}=await Fe(e),u=typeof t=="string"?(await M(t,n,i,c,a)).derived_key:t;if(!(u instanceof Uint8Array))throw new w("The key is not valid.");let s=await Se.subtle.importKey("raw",u,"AES-GCM",!1,["decrypt"]);try{let p=await Se.subtle.decrypt({name:"AES-GCM",iv:n},s,new Uint8Array([...o,...r]));try{return f(p)}catch{throw new q("The ability to directly decrypt binary data has been removed in the new version. If you have encrypted binary data, please recover it using the old version.")}}catch(p){if(!p||!(p instanceof DOMException))throw new m("Internal error.",{cause:p});let l=p.name;throw l==="InvalidAccessError"?new w("InvalidAccessError.",{cause:p}):l==="OperationError"?new ae("Cannot decrypt. Did you provide the correct password?",{cause:p}):new m("Unexpected error.",{cause:p})}}var Oe=["Furina","Neuvillette","Venti","Nahida","Kinich","Kazuha"];async function M(e,t,n=null,o=null,r=null,i=8,a=1,c=32){if(o===null&&(o=262144),typeof o!="number"||o>4194304||i<1||a<1||typeof i!="number"||typeof a!="number"||typeof c!="number")throw new ge;if(typeof e!="string")throw new w("key must be a string");if(!(t instanceof Uint8Array))throw new w("iv must be a Uint8Array");if(n!==null&&typeof n!="string")throw new w("phrase must be a string");if(r||(r=G(64)),n||(n=Oe[je()%Oe.length]),n.includes(":"))throw new w('phrase must not contain ":"');let u=`${n}:${K(r)}`,s=`MyEncryption/1.1 Fontaine/4.2 Iv/${K(t)} user_parameter=${u} user_key=${e}`;return{derived_key:await Te(C(s),r,o,i,a,c),parameter:u,N:o}}async function dt(e,t){let n=20,o=await Y(e);if(o===Z)throw new W("Deriving a key for V1.1 files is not supported");if(o!==X)throw new k;let r=new DataView((await e(n,n+4)).buffer).getUint32(0,!0),i=f(await e(n+4,n+4+r));if(n+=v,r>v)throw new m("(Internal Error) This should not happen. Contact the application developer.");let a=await S(i,t),c=await e(n,n+4),u=new DataView(c.buffer).getUint32(0,!0);n+=4;let s=JSON.parse(f(await e(n,n+u)));n+=u;let p=s.v;if(![5.5].includes(p))throw new k;let[l,d]=s.parameter.split(":"),g=N(d),x=N(s.iv),E=s.N,B=s.a;return ye(B),(await M(a,x,l,E,g)).derived_key}async function ht(e,t,n,o,r,i){return K(await Te(C(e),C(t),n,o,r,i))}var xe=globalThis.crypto;async function et(e,t,n,o=null,r=null,i=null,a=32*1024*1024){if(!a)throw new w("chunk_size must be greater than 0.");await t(C("MyEncryption/1.2"));let c=10020,u=new ArrayBuffer(4);new DataView(u).setUint32(0,c,!0),await t(new Uint8Array(u));let s=K(G(128)),p=await ne(s,n,r,i),l=C(p);if(i=8192,l.length>v)throw new m("(Internal Error) This should not happen. Contact the application developer.");let d=new ArrayBuffer(4);new DataView(d).setUint32(0,l.length,!0),await t(new Uint8Array(d)),await t(l);let g=new Uint8Array(v-l.length-4).fill(0);await t(g),o?.(0),await he();let x=G(12),{derived_key:E,parameter:B,N:F}=await M(s,x,r,i);i=F;let A={parameter:B,N:i,v:5.5,a:"AES-GCM",iv:K(x)},h=C(JSON.stringify(A)),O=new ArrayBuffer(4);new DataView(O).setUint32(0,h.length,!0),await t(new Uint8Array(O)),await t(h);let R=new ArrayBuffer(8);new DataView(R).setBigUint64(0,BigInt(a),!0),await t(new Uint8Array(R));let V=0,P=BigInt(1),T=0,U=new ArrayBuffer(8);new DataView(U).setBigUint64(0,P,!0),await t(new Uint8Array(U)),o?.(0);let y=await xe.subtle.importKey("raw",E,{name:"AES-GCM"},!1,["encrypt"]);for(;;){let I=await e(T,T+a);if(!(I instanceof Uint8Array))throw new D("The file chunk is not a Uint8Array.");if(I.length===0)break;let L=I.length<a,re=new ArrayBuffer(12);if(P>=Ue)throw new Ae("nonce_counter exceeded the maximum value.");if(new DataView(re).setBigUint64(4,P,!0),P++,L){await t(new Uint8Array(se));let b=new ArrayBuffer(8);new DataView(b).setBigUint64(0,BigInt(I.length),!0),await t(new Uint8Array(b))}let ue=new Uint8Array(re),ze=await xe.subtle.encrypt({name:"AES-GCM",iv:ue},y,I),Ke=new Uint8Array(ze);await t(Ke),V+=I.length,T+=I.length,o?.(V)}await t(new Uint8Array(ce));let _=new ArrayBuffer(8);return new DataView(_).setBigUint64(0,BigInt(V),!0),await t(new Uint8Array(_)),await t(new Uint8Array(te)),!0}async function yt(e,t,n,o=null){let r=await e(0,16);if(f(r)!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let i=16,a=await e(i,i+4),c=new DataView(a.buffer).getUint32(0,!0);i+=4;let u=f(await e(i,i+c));i+=1024;let s=await S(u,n),p=await e(i,i+4),l=new DataView(p.buffer).getUint32(0,!0);i+=4;let d=JSON.parse(f(await e(i,i+l)));i+=l;let[g,x]=d.parameter.split(":"),E=N(x),B=N(d.iv),F=d.N;o?.(0),await he();let{derived_key:A}=await M(s,B,g,F,E),h=0,O=await xe.subtle.importKey("raw",A,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let T=await e(i,i+8);if(i+=8,T.every((re,ue)=>re===[255,253,240,16,19,208,18,24][ue]))break;let U=Number(new DataView(T.buffer).getBigUint64(0,!0)),y=await e(i,i+12);i+=12;let _=await e(i,i+U+16);i+=U+16;let I=_,L=await xe.subtle.decrypt({name:"AES-GCM",iv:y},O,I);await t(new Uint8Array(L)),h+=L.byteLength,o&&o(h)}let R=await e(i,i+8),V=Number(new DataView(R.buffer).getBigUint64(0,!0));i+=8;let P=await e(i,i+2);if(h!==V)throw new we("File corrupted: total bytes mismatch");if(!P.every((T,U)=>T===[85,170][U]))throw new fe("Invalid end marker");return!0}async function tt(e,t,n,o=null){let r=20;if(await Y(e)===Z){if(typeof n!="string")throw new W("operation not supported");return await yt(e,t,n,o)}let a=new DataView((await e(r,r+4)).buffer).getUint32(0,!0),c=f(await e(r+4,r+4+a));if(r+=v,a>v)throw new m("(Internal Error) This should not happen. Contact the application developer.");let u=typeof n=="string"?await S(c,n):null,s=await e(r,r+4),p=new DataView(s.buffer).getUint32(0,!0);r+=4;let l=JSON.parse(f(await e(r,r+p)));r+=p;let d=l.v;if(![5.5].includes(d))throw new k;let[g,x]=l.parameter.split(":"),E=N(x),B=N(l.iv),F=l.N,A=l.a;ye(A);let h=Number(new DataView((await e(r,r+8)).buffer).getBigUint64(0,!0)),O=BigInt(new DataView((await e(r+8,r+16)).buffer).getBigUint64(0,!0));r+=16,o?.(0),await he();let R=typeof n=="string"?u?(await M(u,B,g,F,E)).derived_key:Je(new m):n,V=0,P=!1,T=await xe.subtle.importKey("raw",R,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let I=await e(r,r+8),L=0;if(I.every((b,z)=>b===de[z])){let b=await e(r,r+32);if(b.every((z,Ge)=>z===ce[Ge])){r+=32;break}if(b.every((z,Ge)=>z===se[Ge])){P=!0,r+=32;let z=await e(r,r+8);if(r+=8,L=Number(new DataView(z.buffer).getBigUint64(0,!0)),L===0)break}}let re=P?L:h,ue=new ArrayBuffer(12);new DataView(ue).setBigUint64(4,BigInt(O),!0),O++;let ze=await e(r,r+re+16);r+=re+16;let Ke=ze;try{let b=await xe.subtle.decrypt({name:"AES-GCM",iv:new Uint8Array(ue)},T,Ke);await t(new Uint8Array(b)),V+=b.byteLength}catch(b){if(!b||!(b instanceof DOMException))throw new m("Internal error.",{cause:b});let z=b.name;throw z==="InvalidAccessError"?new w("InvalidAccessError.",{cause:b}):z==="OperationError"?new be(void 0,{cause:b}):new m("Unexpected error.",{cause:b})}o&&o(V)}let U=await e(r,r+8),y=Number(new DataView(U.buffer).getBigUint64(0,!0));r+=8;let _=await e(r,r+te.length);if(V!==y)throw new we("total bytes mismatch");if(!_.every((I,L)=>I===te[L]))throw new fe;return!0}async function xt(e,t,n,o,r,i){if(!(e instanceof Blob))throw new w("blob must be a Blob");let a=[];if(!await et(async(s,p)=>new Uint8Array(await e.slice(s,p).arrayBuffer()),async s=>{a.push(s)},t,n,o,r,i))throw new j;return new Blob(a)}async function Et(e,t,n){if(!(e instanceof Blob))throw new w("blob must be a Blob");let o=[];if(!await tt(async(a,c)=>new Uint8Array(await e.slice(a,c).arrayBuffer()),async a=>{o.push(a)},t,n))throw new j;return new Blob(o)}async function _t(e,t,n){if(!(e instanceof Blob))throw new w;if(typeof t!="string"||typeof n!="string")throw new w;if(e.size<1044)throw new D("Data not enough");let o=await Y(async(r,i)=>new Uint8Array(await e.slice(r,i).arrayBuffer()));if(o===Z){let r=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),i=await e.slice(20,20+r).arrayBuffer(),a=f(i);return await ne(await S(a,t),n)}if(o===X){if(e.size<16+v)throw new D("Data not enough");let r=new DataView(await e.slice(20,24).arrayBuffer()).getUint32(0,!0),i=await e.slice(24,24+r).arrayBuffer(),a=f(i);return await ne(await S(a,t),n)}throw new k}async function mt(e,t,n){if(!(e instanceof Blob))throw new w;if(typeof t!="string"||typeof n!="string")throw new w;if(e.size<1044)throw new D("Data not enough");let o=e.slice(0,16);if(await o.text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let i=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),a=f(await e.slice(20,20+i).arrayBuffer()),c=await ne(await S(a,t),n);if(c.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let u=c.length,s=new ArrayBuffer(4);new DataView(s).setUint32(0,u,!0);let l=[o,s,C(c)],d=new Uint8Array(1024-c.length).fill(0);return l.push(d),new Blob(l)}async function gt(e,t,n,o=null,r=null){if(!(e instanceof Blob))throw new w;if(typeof t!="string"||typeof n!="string")throw new w;if(e.size<1044)throw new D("Data not enough");if(await Y(async(x,E)=>new Uint8Array(await e.slice(x,E).arrayBuffer()))===Z)return await mt(e,t,n);let a=new DataView(await e.slice(20,24).arrayBuffer()).getUint32(0,!0),c=f(await e.slice(24,24+a).arrayBuffer());if(!r||!o){let{N:x,phrase:E}=await Fe(c);r||(r=x),o||(o=E)}let u=await ne(await S(c,t),n,o,r);if(u.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let s=u.length,p=new ArrayBuffer(4);new DataView(p).setUint32(0,s,!0);let d=[e.slice(0,20),p,C(u)],g=new Uint8Array(v-u.length-4).fill(0);return d.push(g),new Blob(d)}var Le=Object.create(null);Le[Symbol.toStringTag]="CryptContext";Le.toString=function(){return`${this[Symbol.toStringTag]} Object`};async function Me(e){return e instanceof Promise?await e:e}async function At(){let e=Object.create(Le);return Object.defineProperty(e,"_created",{value:!0}),e}async function bt(e){if(!e||e._released)throw new w("Invalid context");for(let t of Reflect.ownKeys(e)){if(typeof t=="symbol"){Reflect.deleteProperty(e,t);continue}let n=Reflect.get(e,t);n&&(n.release?await Me(n.release()):n.free?await Me(n.free()):n.reset?await Me(n.reset()):n.clear&&await Me(n.clear())),t.startsWith("_")||Reflect.deleteProperty(e,t)}return Object.defineProperty(e,"_released",{value:!0}),!0}var nt=globalThis.crypto,We=class{#n;#e={position:0,end:0,data:null};#t;get[Symbol.toStringTag](){return"Stream"}constructor(t,n){if(typeof t!="function")throw new w("Stream: Invalid reader");if(this.#n=t,typeof n!="number")throw new w("Stream: Invalid size");this.#t=n}get size(){return this.#t}#r=null;async read(t,n,o=null,r=null){if(!this.#n)throw new Error("Stream: The stream has been closed.");if(this.#e.position!=null&&this.#e.end&&this.#e.data&&t>=this.#e.position&&n<=this.#e.end)return this.#e.data.slice(t-this.#e.position,n-this.#e.position);if(t<0)throw new w("Stream: Invalid start position");if(n>this.#t&&(n=this.#t),o!=null&&o>this.#t&&(o=this.#t),this.#r=r,o!=null&&o!==0){let a=await this.#n(t,o,r?.signal);return this.#r=null,this.#e.position=t,this.#e.end=t+a.length,this.#e.data=a,a.slice(0,n-t)}let i=await this.#n(t,n,r?.signal);return this.#r=null,i}abort(){this.#r?.abort()}purge(){this.#e.position=this.#e.end=0,this.#e.data=null}close(){this.#n=null,this.purge()}};async function vt(e,t,n,{cache:o=!0,cache_max_size:r=256*1024*1024}={}){if(e._inited)throw new ve;Object.defineProperty(e,"_inited",{value:!0}),e._type="@decrypt_stream",e.stream={stream:t,release:()=>e.stream.stream.close()};let i=await t.read(0,13,5e3);if(f(i)!=="MyEncryption/")throw new ie;let a=f(await t.read(13,16));if(!["1.1","1.2"].includes(a))throw new k;let c=new DataView((await t.read(16,20)).buffer).getUint32(0,!0),u=pe(a,c),s=20;if(u!==X)throw new W("Cannot perform a streamed decryption on V1.1 files");let p=new DataView((await t.read(s,s+4)).buffer).getUint32(0,!0),l=f(await t.read(s+4,s+4+p));if(s+=v,p>v)throw new m("(Internal Error) This should not happen. Contact the application developer.");let d=await S(l,n),g=await t.read(s,s+4),x=new DataView(g.buffer).getUint32(0,!0);s+=4;let E=JSON.parse(f(await t.read(s,s+x)));s+=x;let B=E.v;if(![5.5].includes(B))throw new k;let[F,A]=E.parameter.split(":"),h=N(A),O=N(E.iv),R=E.N,V=Number(new DataView((await t.read(s,s+8)).buffer).getBigUint64(0,!0)),P=Number(new DataView((await t.read(s+8,s+16)).buffer).getBigUint64(0,!0));s+=16;let{derived_key:T}=await M(d,O,F,R,h),U=await nt.subtle.importKey("raw",T,{name:"AES-GCM"},!1,["decrypt"]);return e.key=U,e.chunk_size=V,e.nonce_counter=P,e.header_json_length=x,e.cache_enabled=!!o,e.cached_chunks=new Map,e.cached_chunks_add_order=new Array,e.cached_size=0,e.cache_max_size=r,!0}async function It(e,t,n,o){if(!e._inited)throw new Ie;if(e._type!=="@decrypt_stream")throw new De(e._type);if(e._released)throw new ke;let r=e.stream.stream,i=e.chunk_size,a=e.nonce_counter,c=[],u=20+v+4+e.header_json_length+8+8,s=i+16,p=Math.floor((r.size-u-(80+te.length))/s),l=Math.max(0,Math.floor(t/i)),d=Math.min(p,Math.floor(n/i));if(d<0||l>p)throw new w("Out of range");let g=async A=>{if(e.cache_enabled&&e.cached_chunks.has(A))return e.cached_chunks.get(A);let h=u+A*s,O=await r.read(h,h+8,h+2*s,o),R=0;if(O.every((y,_)=>y===de[_])){let y=await r.read(h,h+32,null,o);if(h+=32,y.every((_,I)=>_===ce[I]))return!1;if(y.every((_,I)=>_===se[I])){let _=await r.read(h,h+8,null,o);if(h+=8,R=Number(new DataView(_.buffer).getBigUint64(0,!0)),R===0)return!1}}let V=R||i,P=await r.read(h,h+V+16,null,o),T=a+A,U=new ArrayBuffer(12);new DataView(U).setBigUint64(4,BigInt(T),!0);try{let y=await nt.subtle.decrypt({name:"AES-GCM",iv:new Uint8Array(U)},e.key,P);if(e.cache_enabled)for(y.byteLength<e.cache_max_size&&(e.cached_chunks_add_order.push(A),e.cached_chunks.set(A,y),e.cached_size+=y.byteLength);e.cached_size>e.cache_max_size;){let _=e.cached_chunks_add_order.shift();e.cached_size-=e.cached_chunks.get(_).byteLength,e.cached_chunks.delete(_)}return y}catch(y){if(!y||!(y instanceof DOMException))throw new m("Internal error.",{cause:y});let _=y.name;throw _==="InvalidAccessError"?new w("InvalidAccessError.",{cause:y}):_==="OperationError"?new ae("Cannot decrypt. Did you provide the correct password?",{cause:y}):new m("Unexpected error.",{cause:y})}},x=!1;for(let A=l;A<=d;A++){let h=await g(A);if(!h){x=!0;break}c.push(h)}let E=new Blob(c),B=l*i,F=E.slice(t-B,n-B);return x&&(F.eof=!0),F}var Dt={PADDING_SIZE:v,END_IDENTIFIER:de,TAIL_BLOCK_MARKER:se,END_MARKER:ce,FILE_END_MARKER:te,nextTick:he,GetFileVersion:Y,GetFileInfo:Pe,GetFileChunkSize:Qe,derive_key_default_phrases_list:Oe,POWER_2_64:Ue};var ot={};He(ot,{createReaderForFileSystemHandle:()=>kt,createReaderForLocalFile:()=>rt,createReaderForRemoteObject:()=>Nt,createWriterForMemoryBuffer:()=>Bt});async function rt(e){return async(t,n)=>new Uint8Array(await e.slice(t,n).arrayBuffer())}async function kt(e){let t=await e.getFile();return await rt(t)}async function Nt(e){return async(t,n)=>{let o=await fetch(e,{headers:{Range:`bytes=${t}-${n-1}`}});if(!o.ok)throw new me(`Network Error: HTTP ${o.status} : ${o.statusText}`,{response:o});return new Uint8Array(await o.arrayBuffer())}}async function Bt(e){return async t=>{e.push(t)}}var Tt="Encryption/5.6 FileEncryption/1.2 Patch/56.10 Package/1.56.10";export{Le as CryptContext,Z as ENCRYPTION_FILE_VER_1_1_0,X as ENCRYPTION_FILE_VER_1_2_10020,H as Exceptions,We as InputStream,Dt as Internals,Tt as VERSION,ot as Wrappers,gt as change_file_password,At as crypt_context_create,bt as crypt_context_destroy,Et as decrypt_blob,S as decrypt_data,tt as decrypt_file,It as decrypt_stream,vt as decrypt_stream_init,M as derive_key,dt as derive_key_for_file,xt as encrypt_blob,ne as encrypt_data,et as encrypt_file,_t as export_master_key,G as get_random_bytes,st as get_random_int8_number,je as get_random_uint8_number,K as hexlify,wt as is_encrypted_file,lt as is_encrypted_message,pe as normalize_version,Fe as parse_ciphertext,Te as scrypt,ht as scrypt_hex,f as str_decode,C as str_encode,N as unhexlify};
//# sourceMappingURL=main.bundle.min.js.map
