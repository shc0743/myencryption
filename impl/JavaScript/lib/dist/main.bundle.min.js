var Ne=Object.defineProperty;var Ce=(e,t)=>{for(var n in t)Ne(e,n,{get:t[n],enumerable:!0})};function Ve(e){return new Promise((t,n)=>{let o=document.createElement("script");o.src=e,o.onload=()=>t(o),o.onerror=i=>n(i),document.head.append(o)})}function Ie(e,t){return Reflect.has(globalThis,e)?Promise.resolve(Reflect.get(globalThis,e)):Ve(t).then(()=>Reflect.get(globalThis,e))}var Ue=new Array(256);for(let e=0;e<256;e++)Ue[e]=e.toString(16).padStart(2,"0");function L(e){if(!e||!(e instanceof Uint8Array))throw new TypeError("Input must be a Uint8Array");let t=e.length,n=new Array(t);for(let o=0;o<t;o++)n[o]=Ue[e[o]];return n.join("")}var ke={get InvalidHexStringException(){throw new TypeError("Invalid hex string")}};function T(e){if(typeof e!="string")throw new TypeError("Input must be a string");let t=e.length;if(t%2!==0)throw new TypeError("Hex string must have even length");e=e.toLowerCase();let n=new Uint8Array(t>>1);for(let o=0;o<t;o+=2){let i=e.charCodeAt(o),r=e.charCodeAt(o+1),p=i>=97&&i<=102?i-87:i>=48&&i<=57?i-48:ke.InvalidHexStringException,c=r>=97&&r<=102?r-87:r>=48&&r<=57?r-48:ke.InvalidHexStringException;n[o>>1]=p<<4|c}return n}function K(e){let t=new Uint8Array(e);return crypto.getRandomValues(t),t}function Te(){let e=K(1);return new Int8Array(e)[0]}function _e(){let e=K(1);return new Uint8Array(e)[0]}function B(e,t="utf-8"){if(typeof e!="string")throw new TypeError("Input must be a string");if(t.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextEncoder().encode(e)}function f(e,t="utf-8"){if(e instanceof Uint8Array||(e=new Uint8Array(e)),t.toLowerCase()!=="utf-8")throw new Error("Only 'utf-8' encoding is supported");return new TextDecoder().decode(e)}var W={};Ce(W,{BadDataException:()=>R,CannotDecryptException:()=>Y,CryptContextNotInitedException:()=>ie,CryptContextReleasedException:()=>se,CryptContextReusedException:()=>re,EncryptionError:()=>_,EncryptionVersionMismatchException:()=>C,EndOfFileException:()=>me,FileCorruptedException:()=>Q,IVException:()=>ne,InternalError:()=>v,InvalidCryptContextTypeException:()=>ae,InvalidEndMarkerException:()=>ee,InvalidFileFormatException:()=>j,InvalidParameterException:()=>m,InvalidScryptParameterException:()=>te,NotSupportedException:()=>oe,raise:()=>Re});var _=class extends Error{constructor(t="Encryption Error",n=void 0){super(t,n),this.name="EncryptionError"}},v=class extends _{constructor(t="(Internal Error)",n=void 0){super(t,n),this.name="InternalError"}};function Re(e,t){throw new v(e,t)}var m=class extends _{constructor(t="The parameter provided is invalid.",n=void 0){super(t,n),this.name="InvalidParameterException"}},R=class extends _{constructor(t="The data is bad.",n=void 0){super(t,n),this.name="BadDataException"}},te=class extends _{constructor(t="The N, r, or p is not valid or out of range.",n=void 0){super(t,n),this.name="InvalidScryptParameterException"}},C=class extends _{constructor(t="The version of the encryption library doesn't match.",n=void 0){super(t,n),this.name="EncryptionVersionMismatchException"}},j=class extends _{constructor(t="The file format is invalid.",n=void 0){super(t,n),this.name="InvalidFileFormatException"}},ne=class extends _{constructor(t="IV Exception.",n=void 0){super(t,n),this.name="IVException"}},Q=class extends _{constructor(t="File is corrupted.",n=void 0){super(t,n),this.name="FileCorruptedException"}},ee=class extends _{constructor(t="The end marker is invalid.",n=void 0){super(t,n),this.name="InvalidEndMarkerException"}},Y=class extends _{constructor(t="Cannot decrypt",n=void 0){super(t,n),this.name="CannotDecryptException"}},re=class extends _{constructor(t="Not allowed to reuse a crypt context.",n=void 0){super(t,n),this.name="CryptContextReusedException"}},oe=class extends _{constructor(t="Operation not supported",n=void 0){super(t,n),this.name="NotSupportedException"}},me=class extends _{constructor(t="End of File",n=void 0){super(t,n),this.name="EndOfFileException"}},ie=class extends _{constructor(t="Crypt context is not initialized.",n=void 0){super(t,n),this.name="CryptContextNotInitedException"}},ae=class extends _{constructor(t="Invalid crypt context type.",n=void 0){super(t,n),this.name="InvalidCryptContextTypeException"}},se=class extends _{constructor(t="Crypt context has been released.",n=void 0){super(t,n),this.name="CryptContextReleasedException"}};var Z=await Ie("scrypt",import.meta.resolve("./WebScrypt/scrypt.js"));Z.setResPath(import.meta.resolve("./WebScrypt/asset/"));Z.load();var Ee=function(){let e=[],t=!1,n=i=>new Promise(async(r,p)=>{Z.onprogress=c=>{i.onprogress&&i.onprogress(c)},Z.oncomplete=c=>{i.resolve(c),r(!0)},Z.onerror=c=>{i.reject(c),r(!1)};try{Z.config({N:i.N,r:i.r,P:i.p},{maxPassLen:8192,maxSaltLen:2048,maxDkLen:1024,maxThread:1}),await new Promise(c=>Z.onready=c),Z.hash(i.key,i.salt,i.dklen)}catch(c){p(c)}});async function o(){let i=null;for(;e.length;)try{i=e.splice(0,1)[0],await n(i),await Se()}catch(r){i?.reject(r)}t=!1}return function(r,p,c,a,s,u,l=null){return new Promise((h,b)=>{e.push({key:r,salt:p,N:c,r:a,p:s,dklen:u,resolve:h,reject:b,onprogress:l}),t||(t=!0,setTimeout(o))})}}(),Be=["Furina","Neuvillette","Venti","Nahida","Kinich","Kazuha"];async function G(e,t,n=null,o=null,i=null,r=8,p=1,c=32){if(o===null&&(o=262144),typeof o!="number"||o>2097152)throw new te;if(i||(i=K(64)),n||(n=Be[_e()%Be.length]),n.includes(":"))throw new m('phrase MUST NOT contain ":"');let a=`${n}:${L(i)}`,s=`MyEncryption/1.1 Fontaine/4.2 Iv/${L(t)} user_parameter=${a} user_key=${e}`;return{derived_key:await Ee(B(s),i,o,r,p,c),parameter:a,N:o}}function Se(){return new Promise(e=>setTimeout(e))}async function Me(e,t,n,o,i,r){return L(await Ee(B(e),B(t),n,o,i,r))}function Fe(e){try{return JSON.parse(e)}catch{throw new m("The JSON is not valid.")}}async function q(e,t,n=null,o=null){let i=K(12),{derived_key:r,parameter:p,N:c}=await G(t,i,n,o);o=c;let a=await crypto.subtle.importKey("raw",r,"AES-GCM",!1,["encrypt"]);typeof e=="string"&&(e=B(e));let s=await crypto.subtle.encrypt({name:"AES-GCM",iv:i},a,e),u=new Uint8Array(i.length+s.byteLength);u.set(i,0),u.set(new Uint8Array(s),i.length);let l=L(u);return JSON.stringify({data:l,parameter:p,N:o,v:5.5})}async function S(e,t){let n=Fe(e),o=n.parameter,i=parseInt(n.N),r=T(n.data),[p,c]=o.split(":"),a=T(c);if(isNaN(i)||!o||!r||!a)throw new R("The message or parameters are bad.");if(r.length<28)throw new R("The message was too short.");let s=r.slice(0,12),u=r.slice(12,-16),l=r.slice(-16),{derived_key:h}=await G(t,s,p,i,a),b=await crypto.subtle.importKey("raw",h,"AES-GCM",!1,["decrypt"]);try{let w=await crypto.subtle.decrypt({name:"AES-GCM",iv:s},b,new Uint8Array([...u,...l]));try{return f(w)}catch{return w}}catch(w){if(!w)throw new v("Internal error.",{cause:w});let A=w.name;if(A==="InvalidAccessError")throw new m("InvalidAccessError.",{cause:w});if(A==="OperationError")throw new Y("Cannot decrypt. Did you provide the correct password?",{cause:w});if(!w)throw new v("Unexpected error.",{cause:w})}}function Ae(){return new Promise(e=>requestAnimationFrame(e))}var M=4096,ge=[85,170,85,170,85,170,85,170],de=[85,170,85,170,85,170,85,170,170,85,170,85,170,85,170,85,85,170,85,170,85,170,85,170,170,85,170,85,170,85,170,85],he=[85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170,85,170],ce=[255,253,240,16,19,208,18,24,85,170];function J(e,t){return e?(String(e)==="1.1"&&(t=null),t?`${e}/${t}`:`${e}/0`):"Unknown Version"}var pe=J("1.1"),ue=J("1.2",10020);async function Pe(e,t,n,o=null,i=null,r=null,p=32*1024*1024){if(!p)throw new m("chunk_size must be greater than 0.");await t(B("MyEncryption/1.2"));let c=10020,a=new ArrayBuffer(4);new DataView(a).setUint32(0,c,!0),await t(new Uint8Array(a));let s=L(K(64)),u=await q(s,n),l=B(u);if(l.length>M)throw new v("(Internal Error) This should not happen. Contact the application developer.");let h=new ArrayBuffer(4);new DataView(h).setUint32(0,l.length,!0),await t(new Uint8Array(h)),await t(l);let b=new Uint8Array(M-l.length-4).fill(0);await t(b),o?.(0),await Ae();let w=K(12),{derived_key:A,parameter:F,N:P}=await G(s,w,i,r);r=P;let E={parameter:F,N:r,v:5.5,iv:L(w)},y=B(JSON.stringify(E)),O=new ArrayBuffer(4);new DataView(O).setUint32(0,y.length,!0),await t(new Uint8Array(O)),await t(y);let D=new ArrayBuffer(8);new DataView(D).setBigUint64(0,BigInt(p),!0),await t(new Uint8Array(D));let V=0,N=1,g=0,I=new ArrayBuffer(8);new DataView(I).setBigUint64(0,BigInt(N),!0),await t(new Uint8Array(I)),o?.(0);let d=await crypto.subtle.importKey("raw",A,{name:"AES-GCM"},!1,["encrypt"]);for(;;){let k=await e(g,g+p);if(!(k instanceof Uint8Array))throw new R("The file chunk is not a Uint8Array.");if(k.length===0)break;let X=k.length<p,H=new ArrayBuffer(12);if(N>=2**64||N>=Number.MAX_SAFE_INTEGER)throw new ne("nonce_counter exceeded the maximum value.");if(new DataView(H).setBigUint64(4,BigInt(N),!0),N++,X){await t(new Uint8Array(de));let ye=new ArrayBuffer(8);new DataView(ye).setBigUint64(0,BigInt(k.length),!0),await t(new Uint8Array(ye))}let $=new Uint8Array(H),we=await crypto.subtle.encrypt({name:"AES-GCM",iv:$},d,k),le=new Uint8Array(we);await t(le),V+=k.length,g+=k.length,o?.(V)}await t(new Uint8Array(he));let x=new ArrayBuffer(8);return new DataView(x).setBigUint64(0,BigInt(V),!0),await t(new Uint8Array(x)),await t(new Uint8Array(ce)),!0}async function Oe(e,t,n,o=null){let i=await e(0,16);if(f(i)!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let r=16,p=await e(r,r+4),c=new DataView(p.buffer).getUint32(0,!0);r+=4;let a=f(await e(r,r+c));r+=1024;let s=await S(a,n),u=await e(r,r+4),l=new DataView(u.buffer).getUint32(0,!0);r+=4;let h=JSON.parse(f(await e(r,r+l)));r+=l;let[b,w]=h.parameter.split(":"),A=T(w),F=T(h.iv),P=h.N;o?.(0),await Ae();let{derived_key:E}=await G(s,F,b,P,A),y=0,O=await crypto.subtle.importKey("raw",E,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let g=await e(r,r+8);if(r+=8,g.every((H,$)=>H===[255,253,240,16,19,208,18,24][$]))break;let I=Number(new DataView(g.buffer).getBigUint64(0,!0)),d=await e(r,r+12);r+=12;let x=await e(r,r+I+16);r+=I+16;let k=x,X=await crypto.subtle.decrypt({name:"AES-GCM",iv:d},O,k);await t(new Uint8Array(X)),y+=X.byteLength,o&&o(y)}let D=await e(r,r+8),V=Number(new DataView(D.buffer).getBigUint64(0,!0));r+=8;let N=await e(r,r+2);if(y!==V)throw new Q("File corrupted: total bytes mismatch");if(!N.every((g,I)=>g===[85,170][I]))throw new ee("Invalid end marker");return!0}async function ze(e,t,n,o=null){let i=await e(0,13);if(f(i)!=="MyEncryption/")throw new j;let r=f(await e(13,16));if(!["1.1","1.2"].includes(r))throw new C;let p=new DataView((await e(16,20)).buffer).getUint32(0,!0),c=J(r,p),a=20;if(c===pe)return await Oe(e,t,n,o);let s=new DataView((await e(a,a+4)).buffer).getUint32(0,!0),u=f(await e(a+4,a+4+s));if(a+=M,s>M)throw new v("(Internal Error) This should not happen. Contact the application developer.");let l=await S(u,n),h=await e(a,a+4),b=new DataView(h.buffer).getUint32(0,!0);a+=4;let w=JSON.parse(f(await e(a,a+b)));a+=b;let A=w.v;if(![5.5].includes(A))throw new C;let[F,P]=w.parameter.split(":"),E=T(P),y=T(w.iv),O=w.N,D=Number(new DataView((await e(a,a+8)).buffer).getBigUint64(0,!0)),V=Number(new DataView((await e(a+8,a+16)).buffer).getBigUint64(0,!0));a+=16,o?.(0),await Ae();let{derived_key:N}=await G(l,y,F,O,E),g=0,I=!1,d=await crypto.subtle.importKey("raw",N,{name:"AES-GCM"},!1,["decrypt"]);for(;;){let H=await e(a,a+8),$=0;if(H.every((U,z)=>U===ge[z])){let U=await e(a,a+32);if(U.every((z,xe)=>z===he[xe])){a+=32;break}if(U.every((z,xe)=>z===de[xe])){I=!0,a+=32;let z=await e(a,a+8);if(a+=8,$=Number(new DataView(z.buffer).getBigUint64(0,!0)),$===0)break}}let we=I?$:D,le=new ArrayBuffer(12);new DataView(le).setBigUint64(4,BigInt(V),!0),V++;let ye=await e(a,a+we+16);a+=we+16;let De=ye;try{let U=await crypto.subtle.decrypt({name:"AES-GCM",iv:new Uint8Array(le)},d,De);await t(new Uint8Array(U)),g+=U.byteLength}catch(U){if(!U)throw new v("Internal error.",{cause:U});let z=U.name;if(z==="InvalidAccessError")throw new m("InvalidAccessError.",{cause:U});if(z==="OperationError")throw new Y("Cannot decrypt. Did you provide the correct password?",{cause:U});if(!U)throw new v("Unexpected error.",{cause:U})}o&&o(g)}let x=await e(a,a+8),k=Number(new DataView(x.buffer).getBigUint64(0,!0));a+=8;let X=await e(a,a+ce.length);if(g!==k)throw new Q("total bytes mismatch");if(!X.every((H,$)=>H===ce[$]))throw new ee;return!0}async function Le(e,t,n){if(e.size<1044)throw new R("Data not enough");if(await e.slice(0,13).text()!=="MyEncryption/")throw new j;let r=await e.slice(13,16).text();if(!["1.1","1.2"].includes(r))throw new C;let p=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),c=J(r,p);if(c===pe){let a=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),s=await e.slice(20,20+a).arrayBuffer(),u=f(s);return await q(await S(u,t),n)}if(c===ue){if(e.size<16+M)throw new R("Data not enough");let a=new DataView(await e.slice(20,24).arrayBuffer()).getUint32(0,!0),s=await e.slice(24,24+a).arrayBuffer(),u=f(s);return await q(await S(u,t),n)}throw new C}async function Ke(e,t,n){if(e.size<1044)throw new Error("Data not enough");let o=e.slice(0,16);if(await o.text()!=="MyEncryption/1.1")throw new TypeError("Invalid file format");let r=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0),p=f(await e.slice(20,20+r).arrayBuffer()),c=await q(await S(p,t),n);if(c.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let a=c.length,s=new ArrayBuffer(4);new DataView(s).setUint32(0,a,!0);let l=[o,s,B(c)],h=new Uint8Array(1024-c.length).fill(0);return l.push(h),new Blob(l)}async function je(e,t,n){if(e.size<1044)throw new Error("Data not enough");if(await e.slice(0,13).text()!=="MyEncryption/")throw new j;let r=await e.slice(13,16).text();if(!["1.1","1.2"].includes(r))throw new C;let p=new DataView(await e.slice(16,20).arrayBuffer()).getUint32(0,!0);if(J(r,p)===pe)return await Ke(e,t,n);let a=new DataView(await e.slice(20,24).arrayBuffer()).getUint32(0,!0),s=f(await e.slice(24,24+a).arrayBuffer()),u=await q(await S(s,t),n);if(u.length>1024)throw new Error("(Internal Error) This should not happen. Contact the application developer.");let l=u.length,h=new ArrayBuffer(4);new DataView(h).setUint32(0,l,!0);let w=[e.slice(0,20),h,B(u)],A=new Uint8Array(M-u.length-4).fill(0);return w.push(A),new Blob(w)}var ve=Object.create(null);ve[Symbol.toStringTag]="CryptContext";ve.toString=function(){return`${this[Symbol.toStringTag]} Object`};async function fe(e){return e instanceof Promise?await e:e}async function Ge(){let e=Object.create(ve);return Object.defineProperty(e,"_created",{value:!0}),e}async function $e(e){if(!e||e._released)throw new m("Invalid context");for(let t of Reflect.ownKeys(e)){if(typeof t=="symbol"){Reflect.deleteProperty(e,t);continue}let n=Reflect.get(e,t);n&&(n.release?await fe(n.release()):n.free?await fe(n.free()):n.reset?await fe(n.reset()):n.clear&&await fe(n.clear())),t.startsWith("_")||Reflect.deleteProperty(e,t)}return Object.defineProperty(e,"_released",{value:!0}),!0}var be=class{#n=null;#e={position:null,end:null,data:null};#t=null;get[Symbol.toStringTag](){return"Stream"}constructor(t,n){if(typeof t!="function")throw new m("Stream: Invalid reader");if(this.#n=t,typeof n!="number")throw new m("Stream: Invalid size");this.#t=n}get size(){return this.#t}#r=null;async read(t,n,o=null,i=null){if(!this.#n)throw new Error("Stream: The stream has been closed.");if(this.#e.position!=null&&this.#e.end&&this.#e.data&&t>=this.#e.position&&n<=this.#e.end)return this.#e.data.slice(t-this.#e.position,n-this.#e.position);if(t<0)throw new m("Stream: Invalid start position");if(n>this.#t&&(n=this.#t),o>this.#t&&(o=this.#t),this.#r=i,o){let p=await this.#n(t,o,i?.signal);return this.#r=null,this.#e.position=t,this.#e.end=t+p.length,this.#e.data=p,p.slice(0,n-t)}let r=await this.#n(t,n,i?.signal);return this.#r=null,r}abort(){this.#r?.abort()}purge(){this.#e.position=this.#e.data=this.#e.end=null}close(){this.#n=null,this.purge()}};async function Ye(e,t,n,{cache:o=!0,cache_max_size:i=256*1024*1024}={}){if(e._inited)throw new re;Object.defineProperty(e,"_inited",{value:!0}),e._type="@decrypt_stream",e.stream={stream:t,release:()=>e.stream.stream.close()};let r=await t.read(0,13,5e3);if(f(r)!=="MyEncryption/")throw new j;let p=f(await t.read(13,16));if(!["1.1","1.2"].includes(p))throw new C;let c=new DataView((await t.read(16,20)).buffer).getUint32(0,!0),a=J(p,c),s=20;if(a!==ue)throw new oe("Cannot perform a streamed decryption on V1.1 files");let u=new DataView((await t.read(s,s+4)).buffer).getUint32(0,!0),l=f(await t.read(s+4,s+4+u));if(s+=M,u>M)throw new v("(Internal Error) This should not happen. Contact the application developer.");let h=await S(l,n),b=await t.read(s,s+4),w=new DataView(b.buffer).getUint32(0,!0);s+=4;let A=JSON.parse(f(await t.read(s,s+w)));s+=w;let F=A.v;if(![5.5].includes(F))throw new C;let[P,E]=A.parameter.split(":"),y=T(E),O=T(A.iv),D=A.N,V=Number(new DataView((await t.read(s,s+8)).buffer).getBigUint64(0,!0)),N=Number(new DataView((await t.read(s+8,s+16)).buffer).getBigUint64(0,!0));s+=16;let{derived_key:g}=await G(h,O,P,D,y),I=await crypto.subtle.importKey("raw",g,{name:"AES-GCM"},!1,["decrypt"]);return e.key=I,e.chunk_size=V,e.nonce_counter=N,e.header_json_length=w,e.cache_enabled=!!o,e.cached_chunks=new Map,e.cached_chunks_add_order=new Array,e.cached_size=0,e.cache_max_size=i,!0}async function Je(e,t,n,o){if(!e._inited)throw new ie;if(e._type!=="@decrypt_stream")throw new ae(e._type);if(e._released)throw new se;let i=e.stream.stream,r=e.chunk_size,p=e.nonce_counter,c=[],a=20+M+4+e.header_json_length+8+8,s=r+16,u=Math.floor((i.size-a-(80+ce.length))/s),l=Math.max(0,Math.floor(t/r)),h=Math.min(u,Math.floor(n/r));if(h<0||l>u)throw new m("Out of range");let b=async E=>{if(e.cache_enabled&&e.cached_chunks.has(E))return e.cached_chunks.get(E);let y=a+E*s,O=await i.read(y,y+8,y+2*s,o),D=0;if(O.every((d,x)=>d===ge[x])){let d=await i.read(y,y+32,null,o);if(y+=32,d.every((x,k)=>x===he[k]))return!1;if(d.every((x,k)=>x===de[k])){let x=await i.read(y,y+8,null,o);if(y+=8,D=Number(new DataView(x.buffer).getBigUint64(0,!0)),D===0)return!1}}let V=D||r,N=await i.read(y,y+V+16,null,o),g=p+E,I=new ArrayBuffer(12);new DataView(I).setBigUint64(4,BigInt(g),!0);try{let d=await crypto.subtle.decrypt({name:"AES-GCM",iv:new Uint8Array(I)},e.key,N);if(e.cache_enabled)for(d.byteLength<e.cache_max_size&&(e.cached_chunks_add_order.push(E),e.cached_chunks.set(E,d),e.cached_size+=d.byteLength);e.cached_size>e.cache_max_size;){let x=e.cached_chunks_add_order.shift();e.cached_size-=e.cached_chunks.get(x).byteLength,e.cached_chunks.delete(x)}return d}catch(d){if(!d)throw new v("Internal error.",{cause:d});let x=d.name;if(x==="InvalidAccessError")throw new m("InvalidAccessError.",{cause:d});if(x==="OperationError")throw new Y("Cannot decrypt. Did you provide the correct password?",{cause:d});if(!d)throw new v("Unexpected error.",{cause:d})}},w=!1;for(let E=l;E<=h;E++){let y=await b(E);if(!y){w=!0;break}c.push(y)}let A=new Blob(c),F=l*r,P=A.slice(t-F,n-F);return w&&(P.eof=!0),P}var He="Encryption/5.5 FileEncryption/1.2 Patch/4.7";export{pe as ENCRYPTION_FILE_VER_1_1_0,ue as ENCRYPTION_FILE_VER_1_2_10020,W as Exceptions,be as Stream,He as VERSION,je as change_file_password,Ge as crypt_context_create,$e as crypt_context_destroy,S as decrypt_data,ze as decrypt_file,Je as decrypt_stream,Ye as decrypt_stream_init,G as derive_key,q as encrypt_data,Pe as encrypt_file,Le as export_master_key,K as get_random_bytes,Te as get_random_int8_number,_e as get_random_uint8_number,L as hexlify,J as normalize_version,Ee as scrypt,Me as scrypt_hex,f as str_decode,B as str_encode,T as unhexlify};
//# sourceMappingURL=main.bundle.min.js.map
